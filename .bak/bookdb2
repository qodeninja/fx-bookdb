
#!/bin/bash
#
# bookdb - Phase 2: Installer & Database Interface
# A shell-based, context-aware key-value store built on sqlite3.
# This phase implements the installer, environment setup, and the core database
# query function.
#

#
# --- Global Constants & Configuration ---
#
readonly C_RESET='\033[0m';
readonly C_RED='\033[0;31m';

# XDG+ Paths (as per BASHFX architecture)
readonly BOOKDB_ROOT_DIR="${HOME}/.local";
readonly BOOKDB_SHARE_DIR="${BOOKDB_ROOT_DIR}/share/bookdb";
readonly BOOKDB_ETC_DIR="${BOOKDB_ROOT_DIR}/etc/bookdb";
readonly BOOKDB_STATE_DIR="${BOOKDB_ROOT_DIR}/state/bookdb";
readonly BOOKDB_DB_FILE="${BOOKDB_SHARE_DIR}/bookdb.sqlite";
readonly BOOKDB_RC_FILE="${BOOKDB_ETC_DIR}/book.rc";

# Global array to hold arguments after options are parsed.
ARGS=();


#
# --- Cornerstone Functions (Internal Helpers) ---
#

# Writes a log message to stderr, respecting QUIET_MODE.
# Usage: __log "Your message here"
__log() {
  local msg="$1";
  if [[ -z "$QUIET_MODE" ]]; then
    # Using printf for consistency, though echo would work.
    printf "LOG: %s\n" "${msg}" >&2;
  fi;
  return 0;
};

# Writes an error message to stderr, ignoring QUIET_MODE.
# Usage: __error "Something went wrong"
__error() {
  local msg="$1";
  if [[ -n "$NO_COLOR" ]]; then
    printf "ERROR: %s\n" "${msg}" >&2;
  else
    printf "${C_RED}ERROR: %s${C_RESET}\n" "${msg}" >&2;
  fi;
  return 1;
};

# Writes a fatal error message and exits the script with status 1.
# Usage: __fatal "A critical failure occurred"
__fatal() {
  __error "$1";
  exit 1;
};

# Executes a query against the SQLite database.
# stdout is used for SELECT results. stderr is for errors.
# Usage: result=$(__db_query "SELECT ...")
#        __db_query "INSERT ..."
__db_query() {
  local ret=1;
  local query="$1";

  if ! command -v sqlite3 >/dev/null 2>&1; then
    __error "sqlite3 command not found. It is a required dependency.";
    return 1;
  fi;

  if [[ ! -f "${BOOKDB_DB_FILE}" ]]; then
    # This check is for queries run outside the installer context.
    __error "Database file does not exist: ${BOOKDB_DB_FILE}";
    return 1;
  fi;

  # Execute the query. stdout will capture SELECT results.
  # Errors from sqlite3 will go to stderr and be suppressed from capture.
  sqlite3 "${BOOKDB_DB_FILE}" "${query}";
  ret=$?;

  if [[ ${ret} -ne 0 ]]; then
    __error "Database query failed for: ${query}";
  fi;

  return ${ret};
};


#
# --- Command Functions (Business Logic) ---
#

# Sets up the bookdb environment, directories, and database.
dev_install() {
  local ret=1;

  __log "Starting BookDB installation...";

  if ! command -v sqlite3 >/dev/null 2>&1; then
    __fatal "sqlite3 command not found. Please install it to continue.";
  fi;

  __log "Creating XDG+ directories...";
  mkdir -p "${BOOKDB_SHARE_DIR}" || __fatal "Failed to create share dir: ${BOOKDB_SHARE_DIR}";
  mkdir -p "${BOOKDB_ETC_DIR}" || __fatal "Failed to create etc dir: ${BOOKDB_ETC_DIR}";
  mkdir -p "${BOOKDB_STATE_DIR}" || __fatal "Failed to create state dir: ${BOOKDB_STATE_DIR}";

  # Create the DB file so __db_query can use it.
  touch "${BOOKDB_DB_FILE}" || __fatal "Failed to create database file at ${BOOKDB_DB_FILE}";

  __log "Creating database schema...";
  local sql_create_pns="CREATE TABLE project_ns (pns_id INTEGER PRIMARY KEY, pns_name TEXT UNIQUE NOT NULL);";
  local sql_create_kvns="CREATE TABLE keyval_ns (kvns_id INTEGER PRIMARY KEY, kvns_name TEXT NOT NULL, pns_id_fk INTEGER, FOREIGN KEY(pns_id_fk) REFERENCES project_ns(pns_id) ON DELETE CASCADE);";
  local sql_create_vars="CREATE TABLE vars (var_id INTEGER PRIMARY KEY, var_key TEXT NOT NULL, var_value TEXT, var_updated INTEGER, kvns_id_fk INTEGER, FOREIGN KEY(kvns_id_fk) REFERENCES keyval_ns(kvns_id) ON DELETE CASCADE);";

  __db_query "${sql_create_pns}" || __fatal "Failed to create 'project_ns' table.";
  __db_query "${sql_create_kvns}" || __fatal "Failed to create 'keyval_ns' table.";
  __db_query "${sql_create_vars}" || __fatal "Failed to create 'vars' table.";

  __log "Initializing default namespaces...";
  __db_query "INSERT INTO project_ns (pns_name) VALUES ('GLOBAL');" || __fatal "Failed to create GLOBAL project.";
  local global_pns_id=$(__db_query "SELECT pns_id FROM project_ns WHERE pns_name = 'GLOBAL';");
  __db_query "INSERT INTO keyval_ns (kvns_name, pns_id_fk) VALUES ('MAIN', ${global_pns_id});" || __fatal "Failed to create MAIN key-value store for GLOBAL.";

  __log "Generating RC file...";
  cat << EOF > "${BOOKDB_RC_FILE}";
# bookdb runtime configuration
# Source this file in your ~/.bashrc, ~/.zshrc, etc.
#
#   printf "\\n# bookdb configuration\\nsource %s\\n" "${BOOKDB_RC_FILE}" >> ~/.bashrc

export BOOKDB_HOME="${BOOKDB_SHARE_DIR}"
export BOOKDB_INSTALLED="true"
EOF

  if [[ $? -ne 0 ]]; then
      __fatal "Failed to create RC file: ${BOOKDB_RC_FILE}";
  fi;

  # Use printf for better control and to direct to stderr.
  printf "\n[OKAY] Installation successful!\n\n" >&2;
  printf "To complete the setup, add the following line to your shell profile\n" >&2;
  printf "(e.g., ~/.bashrc, ~/.zshrc, or ~/.profile):\n\n" >&2;
  printf "    source %s\n\n" "${BOOKDB_RC_FILE}" >&2;

  ret=0;
  return ${ret};
};

# A test function to verify database read/write.
dev_test_db() {
    __log "Running database R/W test...";
    local test_key="db_test_$$";
    local test_val="success";
    local ts;
    ts=$(date +%s);

    # kvns_id_fk=1 corresponds to the GLOBAL.MAIN namespace created during install.
    local sql_insert="INSERT INTO vars (var_key, var_value, var_updated, kvns_id_fk) VALUES ('${test_key}', '${test_val}', ${ts}, 1);";
    __db_query "${sql_insert}";
    if [[ $? -ne 0 ]]; then
        __fatal "DB TEST FAILED: Could not insert test key.";
    fi;

    local sql_select="SELECT var_value FROM vars WHERE var_key = '${test_key}';";
    local res;
    res=$(__db_query "${sql_select}");
     if [[ $? -ne 0 ]]; then
        __fatal "DB TEST FAILED: Could not select test key.";
    fi;

    if [[ "${res}" != "${test_val}" ]]; then
        __fatal "DB TEST FAILED: Mismatch on read. Expected '${test_val}' but got '${res}'.";
    fi;

    __log "DB read/write successful.";
    local sql_delete="DELETE FROM vars WHERE var_key = '${test_key}';";
    __db_query "${sql_delete}" || __error "DB TEST CLEANUP FAILED: Could not delete test key.";

    __log "DB Test OKAY.";
    return 0;
};


#
# --- Core Application Logic ---
#

# Displays usage information and exits.
usage() {
  cat << EOF >&2
Usage: bookdb <command> [args...] [flags...]

A shell-based key-value store.

Phase 2: Installer and DB Interface.

Available commands:
  dev-install     - Manually run the installer.
  dev-test-db     - Run a test to verify database R/W.
  <any-command>   - Echos the command being dispatched.

Flags:
  -q, --quiet     - Suppress all output except for errors.

EOF
  exit 1;
};

# Parses command-line options and populates global option variables.
options() {
  local local_args=();
  opt_quiet=;

  while [ $# -gt 0 ]; do
    case "$1" in
      (-q|--quiet)
        opt_quiet=1;
        shift;
        ;;
      (--)
        shift;
        local_args+=("$@");
        break;
        ;;
      (-*)
        __error "Unknown option: $1";
        usage;
        ;;
      (*)
        local_args+=("$1");
        shift;
        ;;
    esac;
  done;

  ARGS=("${local_args[@]}");
  return 0;
};

# Routes commands to their corresponding functions.
dispatch() {
  local ret=1;
  local cmd="${ARGS[0]}";

  if [[ -z "$cmd" ]]; then
    usage;
  fi;

  case "$cmd" in
    (dev-install)
      dev_install;
      ret=$?;
      ;;
    (dev-test-db)
      dev_test_db;
      ret=$?;
      ;;
    (*)
      __log "Dispatching: ${cmd}";
      ret=0;
      ;;
  esac;

  return ${ret};
};

# The main entrypoint for the script.
main() {
  # Check for installation artifact. If not found, run installer.
  # Using BOOKDB_INSTALLED from the RC file is a more robust check once sourced,
  # but checking for the DB file is the required first-run trigger.
  if [[ ! -f "${BOOKDB_DB_FILE}" ]]; then
    # Allow explicit `dev-install` to be the only command that can run
    # before installation is complete.
    if [[ "$1" != "dev-install" ]]; then
      __log "BookDB database not found. Running installer for first-time setup.";
      dev_install;
      # Exit after install, user needs to source the new RC file.
      exit $?;
    fi;
  fi;

  # Parse all command-line options.
  options "$@";

  # Set global modes based on parsed options.
  if [[ -n "$opt_quiet" ]]; then
    QUIET_MODE=true;
  fi;

  # Hand control over to the command dispatcher.
  dispatch;
  local ret=$?;

  return ${ret};
};


#
# --- Execution Entry Point ---
#
main "$@";
