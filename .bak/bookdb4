#!/bin/bash
#
# bookdb - Final MVP (Phase 5) with Dev and Safety Tools
# A shell-based, context-aware key-value store built on sqlite3.
#

#
# --- Global Constants & Configuration ---
#
readonly C_RESET='\033[0m';
readonly C_RED='\033[0;31m';
readonly C_BLUE='\033[0;34m';
readonly C_YELLOW='\033[0;33m';
readonly C_BOLD='\033[1m';

# --- Developer & Safety Toggles ---
# Set DEV_MODE to true to bypass all [y/N] confirmation prompts.
DEV_MODE=true;
# Set SAFE_MODE to true to automatically back up the DB before destructive actions.
SAFE_MODE=true;

# XDG+ Paths (as per BASHFX architecture)
readonly BOOKDB_ROOT_DIR="${HOME}/.local";
readonly BOOKDB_SHARE_DIR="${BOOKDB_ROOT_DIR}/share/bookdb";
readonly BOOKDB_ETC_DIR="${BOOKDB_ROOT_DIR}/etc/bookdb";
readonly BOOKDB_STATE_DIR="${BOOKDB_ROOT_DIR}/state/bookdb";
readonly BOOKDB_DB_FILE="${BOOKDB_SHARE_DIR}/bookdb.sqlite";
readonly BOOKDB_RC_FILE="${BOOKDB_ETC_DIR}/book.rc";
readonly BOOKDB_CURSOR_FILE="${BOOKDB_STATE_DIR}/cursor";

# Global array to hold arguments after options are parsed.
ARGS=();
# Global context state variables
BOOKDB_PNS_ID=;
BOOKDB_PNS_NAME=;
BOOKDB_KVNS_ID=;
BOOKDB_KVNS_NAME=;


#
# --- Cornerstone Functions (Internal Helpers) ---
#

__log() {
  local msg="$1";
  if [[ -z "$QUIET_MODE" ]]; then
    printf "LOG: %s\n" "${msg}" >&2;
  fi;
  return 0;
};

__error() {
  local msg="$1";
  if [[ -n "$NO_COLOR" ]]; then
    printf "ERROR: %s\n" "${msg}" >&2;
  else
    printf "${C_RED}ERROR: %s${C_RESET}\n" "${msg}" >&2;
  fi;
  return 1;
};

__fatal() {
  __error "$1";
  exit 1;
};

__db_query() {
  local ret=1;
  local query="$1";
  shift;
  if ! command -v sqlite3 >/dev/null 2>&1; then
    __error "sqlite3 command not found. It is a required dependency.";
    return 1;
  fi;
  if [[ ! -f "${BOOKDB_DB_FILE}" ]]; then
    __error "Database file does not exist: ${BOOKDB_DB_FILE}";
    return 1;
  fi;
  sqlite3 "$@" "${BOOKDB_DB_FILE}" "${query}";
  ret=$?;
  if [[ ${ret} -ne 0 ]]; then
    __error "Database query failed for: ${query}";
  fi;
  return ${ret};
};

__persist_cursor() {
  local pns_name="$1";
  local kvns_name="$2";
  if [[ -z "$pns_name" || -z "$kvns_name" ]]; then
    __error "Cannot persist invalid cursor (PNS: ${pns_name}, KVNS: ${kvns_name})";
    return 1;
  fi;
  printf "%s\n%s\n" "${pns_name}" "${kvns_name}" > "${BOOKDB_CURSOR_FILE}.tmp";
  mv "${BOOKDB_CURSOR_FILE}.tmp" "${BOOKDB_CURSOR_FILE}" || __fatal "Failed to write cursor file";
  return 0;
};

__backup_db() {
  if [[ "${SAFE_MODE}" != "true" ]]; then return 0; fi;
  if [[ ! -f "${BOOKDB_DB_FILE}" ]]; then return 0; fi;

  local ts;
  ts=$(date +%Y%m%d-%H%M%S);
  local backup_dir="${BOOKDB_SHARE_DIR}/backups";
  local backup_file="${backup_dir}/bookdb-backup-${ts}.tar.gz";

  mkdir -p "${backup_dir}" || __error "Could not create backup directory.";
  __log "SAFE_MODE: Backing up database to ${backup_file}";
  tar -czf "${backup_file}" -C "$(dirname "${BOOKDB_DB_FILE}")" "$(basename "${BOOKDB_DB_FILE}")";
  if [[ $? -ne 0 ]]; then
    __error "Backup failed!";
  fi;
  return 0;
};

__confirm_action() {
  local prompt_msg="$1";
  if [[ "${DEV_MODE}" == "true" ]]; then
    __log "DEV_MODE: Auto-confirming action.";
    return 0;
  fi;
  if [[ -n "$opt_yes" ]]; then
    return 0;
  fi;
  local confirm;
  printf "${C_YELLOW}%s${C_RESET} [y/N]: " "${prompt_msg}" >&2;
  read confirm;
  if [[ "${confirm}" == "y" || "${confirm}" == "Y" ]]; then
    return 0;
  else
    return 1;
  fi;
};

__resolve_context() {
  local ret=1;
  local T_pns_name=;
  local T_kvns_name=;
  local persist_needed=0;
  if [[ -n "${opt_context_chain}" ]]; then
    persist_needed=1;
    local clean_chain="${opt_context_chain#*@}";
    clean_chain="${clean_chain#*%}";
    T_pns_name=$(echo "${clean_chain}" | cut -d'.' -f1);
    T_kvns_name=$(echo "${clean_chain}" | cut -d'.' -f3);
    local context_type=$(echo "${clean_chain}" | cut -d'.' -f2);
    if [[ "${context_type}" != "VAR" ]]; then
      __fatal "Invalid context chain: middle part must be 'VAR' (e.g., @myproj.VAR.config)";
    fi;
  fi;
  if [[ -n "${opt_projdb}" ]]; then
    persist_needed=1;
    T_pns_name="${opt_projdb}";
  fi;
  if [[ -n "${opt_keydb}" ]]; then
    persist_needed=1;
    T_kvns_name="${opt_keydb}";
  fi;
  if [[ -z "${T_pns_name}" && -z "${T_kvns_name}" ]]; then
    if [[ -f "${BOOKDB_CURSOR_FILE}" ]]; then
      T_pns_name=$(sed -n '1p' "${BOOKDB_CURSOR_FILE}");
      T_kvns_name=$(sed -n '2p' "${BOOKDB_CURSOR_FILE}");
    else
      T_pns_name="GLOBAL";
      T_kvns_name="MAIN";
    fi;
  fi;
  if [[ -z "${T_pns_name}" ]]; then
      T_pns_name=$(sed -n '1p' "${BOOKDB_CURSOR_FILE}" 2>/dev/null || echo "GLOBAL");
  fi;
  if [[ -z "${T_kvns_name}" ]]; then
      T_kvns_name=$(sed -n '2p' "${BOOKDB_CURSOR_FILE}" 2>/dev/null || echo "MAIN");
  fi;
  local pns_name_sql="${T_pns_name//\'/\'\'}";
  local kvns_name_sql="${T_kvns_name//\'/\'\'}";
  local T_pns_id;
  T_pns_id=$(__db_query "SELECT pns_id FROM project_ns WHERE pns_name = '${pns_name_sql}';");
  if [[ -z "${T_pns_id}" ]]; then
    __error "Project Namespace not found: '${T_pns_name}'";
    return 1;
  fi;
  local T_kvns_id;
  T_kvns_id=$(__db_query "SELECT kvns_id FROM keyval_ns WHERE kvns_name = '${kvns_name_sql}' AND pns_id_fk = ${T_pns_id};");
  if [[ -z "${T_kvns_id}" ]]; then
    __error "Key-Value Namespace not found: '${T_kvns_name}' in project '${T_pns_name}'";
    return 1;
  fi;
  BOOKDB_PNS_ID="${T_pns_id}";
  BOOKDB_PNS_NAME="${T_pns_name}";
  BOOKDB_KVNS_ID="${T_kvns_id}";
  BOOKDB_KVNS_NAME="${T_kvns_name}";
  if [[ ${persist_needed} -eq 1 ]]; then
    __log "Persisting new context to cursor: ${BOOKDB_PNS_NAME}.${BOOKDB_KVNS_NAME}";
    __persist_cursor "${BOOKDB_PNS_NAME}" "${BOOKDB_KVNS_NAME}";
  fi;
  ret=0;
  return ${ret};
};


#
# --- Command Functions (Business Logic) ---
#

do_getv() {
  local ret=1;
  local key="$1";
  if [[ -z "${key}" ]]; then __error "Usage: bookdb getv <KEY>"; return 1; fi;
  local key_sql="${key//\'/\'\'}";
  local sql="SELECT var_value FROM vars WHERE var_key = '${key_sql}' AND kvns_id_fk = ${BOOKDB_KVNS_ID};";
  __db_query "${sql}";
  ret=$?;
  return ${ret};
};

do_setv() {
  local ret=1;
  local arg="$1";
  local key="${arg%%=*}";
  local val="${arg#*=}";
  if [[ -z "$key" ]]; then
    __error "Usage: bookdb setv <KEY=VALUE>";
    return 1;
  fi;
  local key_sql="${key//\'/\'\'}";
  local val_sql="${val//\'/\'\'}";
  local ts;
  ts=$(date +%s);
  local var_id;
  var_id=$(__db_query "SELECT var_id FROM vars WHERE var_key = '${key_sql}' AND kvns_id_fk = ${BOOKDB_KVNS_ID};");
  
  if [[ -z "${var_id}" ]]; then
    __log "Creating new variable: '${key}'";
    local sql_insert="INSERT INTO vars (var_key, var_value, var_updated, kvns_id_fk) VALUES ('${key_sql}', '${val_sql}', ${ts}, ${BOOKDB_KVNS_ID});";
    __db_query "${sql_insert}";
    ret=$?;
  else
    __log "Updating existing variable: '${key}'";
    local sql_update="UPDATE vars SET var_value = '${val_sql}', var_updated = ${ts} WHERE var_id = ${var_id};";
    __db_query "${sql_update}";
    ret=$?;
  fi;
  return ${ret};
};

do_delv() {
  local ret=1;
  local key="$1";
  if [[ -z "${key}" ]]; then
    __error "Usage: bookdb delv <KEY>";
    return 1;
  fi;
  local key_sql="${key//\'/\'\'}";
  __backup_db;
  __db_query "DELETE FROM vars WHERE var_key = '${key_sql}' AND kvns_id_fk = ${BOOKDB_KVNS_ID};";
  ret=$?;
  __log "Deleted variable: ${key}";
  return ${ret};
};

do_ls() {
  local ret=1;
  local what="$1";
  case "${what}" in
    (project)
      __db_query "SELECT pns_name FROM project_ns ORDER BY pns_name;";
      ret=$?;
      ;;
    (vars)
      local sql="SELECT kvns_name FROM keyval_ns WHERE pns_id_fk = ${BOOKDB_PNS_ID} ORDER BY kvns_name;";
      __db_query "${sql}";
      ret=$?;
      ;;
    ("")
      local sql="SELECT var_key FROM vars WHERE kvns_id_fk = ${BOOKDB_KVNS_ID} ORDER BY var_key;";
      __db_query "${sql}";
      ret=$?;
      ;;
    (*)
      __error "Invalid argument for 'ls'. Use 'project', 'vars', or no argument.";
      return 1;
      ;;
  esac;
  return ${ret};
};

do_new() {
  local ret=1;
  local what="${ARGS[1]}";
  local ns_name="${opt_ns}";
  if [[ -z "${what}" || -z "${ns_name}" ]]; then
    __error "Usage: bookdb new <project|keyval> --ns <name>";
    return 1;
  fi;
  local name_sql="${ns_name//\'/\'\'}";
  case "${what}" in
    (project)
      __backup_db;
      __db_query "INSERT INTO project_ns (pns_name) VALUES ('${name_sql}');";
      if [[ $? -eq 0 ]]; then
        __log "Project '${ns_name}' created.";
        local new_pns_id;
        new_pns_id=$(__db_query "SELECT pns_id FROM project_ns WHERE pns_name = '${name_sql}';");
        __db_query "INSERT INTO keyval_ns (kvns_name, pns_id_fk) VALUES ('MAIN', ${new_pns_id});";
        __log "Default key-value store 'MAIN' created for project '${ns_name}'.";
        ret=0;
      else
        __error "Failed to create project '${ns_name}'. It may already exist.";
        ret=1;
      fi;
      ;;
    (keyval)
      __backup_db;
      __db_query "INSERT INTO keyval_ns (kvns_name, pns_id_fk) VALUES ('${name_sql}', ${BOOKDB_PNS_ID});";
      if [[ $? -eq 0 ]]; then
        __log "Key-value store '${ns_name}' created in project '${BOOKDB_PNS_NAME}'.";
        ret=0;
      else
        __error "Failed to create key-value store '${ns_name}'. It may already exist in this project.";
        ret=1;
      fi;
      ;;
    (*)
      __error "Invalid argument for 'new'. Use 'project' or 'keyval'.";
      ret=1;
      ;;
  esac;
  return ${ret};
};

do_del() {
  local ret=1;
  local what="${ARGS[1]}";
  local ns_name="${opt_ns}";
  if [[ -z "${what}" || -z "${ns_name}" ]]; then
    __error "Usage: bookdb del <project|keyval> --ns <name>";
    return 1;
  fi;
  local name_sql="${ns_name//\'/\'\'}";
  case "${what}" in
    (project)
      if __confirm_action "Delete project '${ns_name}' and ALL its contents?"; then
        __backup_db;
        __db_query "DELETE FROM project_ns WHERE pns_name = '${name_sql}';";
        ret=$?;
        __log "Project '${ns_name}' deleted.";
      else
        __log "Deletion cancelled.";
        ret=1;
      fi;
      ;;
    (keyval)
      if __confirm_action "Delete key-value store '${ns_name}' in project '${BOOKDB_PNS_NAME}'?"; then
        __backup_db;
        __db_query "DELETE FROM keyval_ns WHERE kvns_name = '${name_sql}' AND pns_id_fk = ${BOOKDB_PNS_ID};";
        ret=$?;
        __log "Key-value store '${ns_name}' deleted.";
      else
        __log "Deletion cancelled.";
        ret=1;
      fi;
      ;;
    (*)
      __error "Invalid argument for 'del'. Use 'project' or 'keyval'.";
      ret=1;
      ;;
  esac;
  return ${ret};
};

do_backup() {
    local base_path="${HOME}/bookdb_backup.tar.gz";
    local backup_path="${base_path}";
    local i=1;

    # Find the next available incremental backup number
    while [[ -f "${backup_path}" ]]; do
        backup_path="${HOME}/bookdb_backup_${i}.tar.gz";
        i=$((i + 1));
    done;

    __log "Creating full backup at: ${backup_path}";
    # Backup the entire bookdb installation structure from ~/.local
    tar -czf "${backup_path}" -C "${BOOKDB_ROOT_DIR}" "share/bookdb" "etc/bookdb" "state/bookdb";
    
    if [[ $? -eq 0 ]]; then
        __log "Backup successful.";
        return 0;
    else
        __error "Backup failed.";
        return 1;
    fi;
};

do_cursor() { printf "Active Cursor: @%s.VAR.%s\n" "${BOOKDB_PNS_NAME}" "${BOOKDB_KVNS_NAME}" >&2; return 0; };
do_status() {
  printf "--- BookDB Status ---\n" >&2;
  printf "  ${C_BLUE}Database File:${C_RESET} %s\n" "${BOOKDB_DB_FILE}" >&2;
  printf "  ${C_BLUE}Cursor File:${C_RESET}   %s\n" "${BOOKDB_CURSOR_FILE}" >&2;
  printf "  ${C_BLUE}Active Cursor:${C_RESET} ${C_YELLOW}@%s.VAR.%s${C_RESET}\n" "${BOOKDB_PNS_NAME}" "${BOOKDB_KVNS_NAME}" >&2;
  printf "  ${C_BLUE}Projects:${C_RESET}\n" >&2;
  local projects; projects=$(do_ls "project");
  if [[ -n "${projects}" ]]; then echo "${projects}" | sed 's/^/    - /' >&2;
  else printf "    (No projects found)\n" >&2; fi;
  return 0;
};
do_reset() {
  if __confirm_action "This will permanently delete all bookdb data. Continue?"; then
    __backup_db;
    __log "Proceeding with reset...";
    rm -rf "${BOOKDB_SHARE_DIR}" "${BOOKDB_ETC_DIR}" "${BOOKDB_STATE_DIR}";
    printf "\n[OKAY] Reset complete.\n" >&2;
    return 0;
  else
    __log "Reset cancelled.";
    return 1;
  fi;
};
do_install() {
  local ret=1;
  __log "Starting BookDB installation...";
  if ! command -v sqlite3 >/dev/null 2>&1; then __fatal "sqlite3 command not found."; fi;
  __log "Creating XDG+ directories...";
  mkdir -p "${BOOKDB_SHARE_DIR}" || __fatal "Failed to create share dir";
  mkdir -p "${BOOKDB_ETC_DIR}" || __fatal "Failed to create etc dir";
  mkdir -p "${BOOKDB_STATE_DIR}" || __fatal "Failed to create state dir";
  touch "${BOOKDB_DB_FILE}" || __fatal "Failed to create database file";
  __log "Creating/verifying database schema...";
  local sql_create_pns="CREATE TABLE IF NOT EXISTS project_ns (pns_id INTEGER PRIMARY KEY, pns_name TEXT UNIQUE NOT NULL);";
  local sql_create_kvns="CREATE TABLE IF NOT EXISTS keyval_ns (kvns_id INTEGER PRIMARY KEY, kvns_name TEXT NOT NULL, pns_id_fk INTEGER, FOREIGN KEY(pns_id_fk) REFERENCES project_ns(pns_id) ON DELETE CASCADE, UNIQUE(kvns_name, pns_id_fk));";
  local sql_create_vars="CREATE TABLE IF NOT EXISTS vars (var_id INTEGER PRIMARY KEY, var_key TEXT NOT NULL, var_value TEXT, var_updated INTEGER, kvns_id_fk INTEGER, FOREIGN KEY(kvns_id_fk) REFERENCES keyval_ns(kvns_id) ON DELETE CASCADE);";
  __db_query "${sql_create_pns}" || __fatal "Failed table: project_ns";
  __db_query "${sql_create_kvns}" || __fatal "Failed table: keyval_ns";
  __db_query "${sql_create_vars}" || __fatal "Failed table: vars";
  __log "Initializing/verifying default namespaces...";
  __db_query "INSERT OR IGNORE INTO project_ns (pns_name) VALUES ('GLOBAL');" || __fatal "Failed to create GLOBAL";
  local global_pns_id=$(__db_query "SELECT pns_id FROM project_ns WHERE pns_name = 'GLOBAL';");
  __db_query "INSERT OR IGNORE INTO keyval_ns (kvns_name, pns_id_fk) VALUES ('MAIN', ${global_pns_id});" || __fatal "Failed to create MAIN";
  __log "Generating RC file...";
  cat << EOF > "${BOOKDB_RC_FILE}";
# bookdb runtime configuration
export BOOKDB_HOME="${BOOKDB_SHARE_DIR}"
export BOOKDB_INSTALLED="true"
EOF
  if [[ $? -ne 0 ]]; then __fatal "Failed to create RC file"; fi;
  printf "\n[OKAY] Installation is complete and up to date.\n\n" >&2;
  printf "To complete setup, add to your shell profile:\n\n" >&2;
  printf "    source %s\n\n" "${BOOKDB_RC_FILE}" >&2;
  ret=0;
  return ${ret};
};
do_tables() { printf "Tables in %s:\n" "${BOOKDB_DB_FILE}" >&2; __db_query ".tables" >&2; return $?; };
do_tdump() {
  local table_name="$1";
  if [[ -z "${table_name}" ]]; then __error "Usage: bookdb tdump <TABLE_NAME>"; return 1; fi;
  if ! [[ "${table_name}" =~ ^[a-zA-Z0-9_]+$ ]]; then __error "Invalid table name specified."; return 1; fi;
  printf "Dumping table: %s\n" "${table_name}" >&2;
  __db_query "SELECT * FROM ${table_name};" "-header" "-column" >&2;
  return $?;
};
# do_dev_setup() {
#   __log "Starting developer test setup...";
#   do_install;
#   # Use main to call commands, which ensures all logic (like __backup_db) is respected.
#   # Use the -y flag to auto-confirm any prompts during setup.
#   main new project --ns myapp -y;
#   main new keyval --ns secrets @GLOBAL.VAR.MAIN -y;
#   main new keyval --ns apis @myapp.VAR.MAIN -y;
#   main setv DB_PASS=supersecret @GLOBAL.VAR.secrets -y;
#   main setv GOOGLE_API_KEY=key-for-google @myapp.VAR.apis -y;
#   __log "Developer setup complete.";
#   return 0;
# };


do_dev_setup() {
  __log "Starting developer test setup...";
  # First, ensure a clean slate. This respects DEV_MODE/-y passed from main().
  do_reset;
  if [[ $? -ne 0 ]]; then __fatal "Reset cancelled during dev-setup."; fi;
  
  # Then, run a clean install.
  do_install;
  if [[ $? -ne 0 ]]; then __fatal "Installation failed during dev-setup."; fi;

  __log "Inserting test data via direct queries...";
  # Create 'myapp' project
  __db_query "INSERT OR IGNORE INTO project_ns (pns_name) VALUES ('myapp');";
  local myapp_id;
  myapp_id=$(__db_query "SELECT pns_id FROM project_ns WHERE pns_name = 'myapp';");
  
  # Create 'secrets' keyval store in GLOBAL
  local global_id;
  global_id=$(__db_query "SELECT pns_id FROM project_ns WHERE pns_name = 'GLOBAL';");
  __db_query "INSERT OR IGNORE INTO keyval_ns (kvns_name, pns_id_fk) VALUES ('secrets', ${global_id});";

  # Create 'apis' keyval store in 'myapp'
  __db_query "INSERT OR IGNORE INTO keyval_ns (kvns_name, pns_id_fk) VALUES ('apis', ${myapp_id});";

  # Set variables
  local secrets_id;
  secrets_id=$(__db_query "SELECT kvns_id from keyval_ns WHERE kvns_name = 'secrets' AND pns_id_fk = ${global_id};");
  __db_query "INSERT OR IGNORE INTO vars (var_key, var_value, kvns_id_fk) VALUES ('DB_PASS', 'supersecret', ${secrets_id});";

  local apis_id;
  apis_id=$(__db_query "SELECT kvns_id from keyval_ns WHERE kvns_name = 'apis' AND pns_id_fk = ${myapp_id};");
  __db_query "INSERT OR IGNORE INTO vars (var_key, var_value, kvns_id_fk) VALUES ('GOOGLE_API_KEY', 'key-for-google', ${apis_id});";

  __log "Developer setup complete.";
  return 0;
};


#
# --- Core Application Logic ---
#

usage() {
  cat << EOF >&2
Usage: bookdb <command> [args...] [flags...] [<context-chain>]

A shell-based key-value store.

Core Commands:
  status                   - Display a dashboard of the system's state.
  cursor                   - Print the current active cursor chain.
  ls [project|vars]        - List projects, key-val namespaces, or variables.
  getv <KEY>               - Get the value of a variable.
  setv <KEY=VALUE>         - Create or update a variable.
  delv <KEY>               - Delete a variable.
  new <project|keyval> --ns <name>
                           - Create a new project or key-value namespace.
  del <project|keyval> --ns <name>
                           - Delete a project or key-value namespace.

Admin & Dev Commands:
  install                  - Create or verify a bookdb installation.
  reset                    - DELETE ALL DATA and artifacts.
  backup                   - Create a full, versioned backup in \$HOME.
  dev-setup                - Create a standard set of test data.
  tables                   - List all tables in the database.
  tdump <NAME>             - Dump the contents of a specific table.

Flags:
  -y, --yes                - Auto-confirm 'yes' to all prompts.
EOF
  exit 1;
};

options() {
  local local_args=();
  opt_quiet=; opt_projdb=; opt_keydb=; opt_context_chain=; opt_ns=; opt_yes=;
  while [ $# -gt 0 ]; do
    case "$1" in
      (-q|--quiet) opt_quiet=1; shift; ;;
      (-y|--yes) opt_yes=1; shift; ;;
      (-p|--projdb) opt_projdb="$2"; shift 2; ;;
      (-k|--keydb) opt_keydb="$2"; shift 2; ;;
      (--ns) opt_ns="$2"; shift 2; ;;
      (--) shift; local_args+=("$@"); break; ;;
      (-*) __error "Unknown option: $1"; usage; ;;
      (*) local_args+=("$1"); shift; ;;
    esac;
  done;
  local last_arg_idx=$((${#local_args[@]} - 1));
  if [[ ${last_arg_idx} -ge 0 ]]; then
    local last_arg="${local_args[${last_arg_idx}]}";
    if [[ "${last_arg}" == \@* || "${last_arg}" == \%* ]]; then
      opt_context_chain="${last_arg}";
      unset 'local_args[${last_arg_idx}]';
    fi;
  fi;
  ARGS=("${local_args[@]}");
  return 0;
};

dispatch() {
  local ret=1;
  local cmd="${ARGS[0]}";
  if [[ -z "$cmd" ]]; then usage; fi;
  case "$cmd" in
    (status) do_status; ret=$?; ;;
    (cursor) do_cursor; ret=$?; ;;
    (getv) do_getv "${ARGS[1]}"; ret=$?; ;;
    (setv) do_setv "${ARGS[1]}"; ret=$?; ;;
    (delv) do_delv "${ARGS[1]}"; ret=$?; ;;
    (ls) do_ls "${ARGS[1]}"; ret=$?; ;;
    (new) do_new; ret=$?; ;;
    (del) do_del; ret=$?; ;;
    (tables) do_tables; ret=$?; ;;
    (tdump) do_tdump "${ARGS[1]}"; ret=$?; ;;
    (reset) do_reset; ret=$?; ;;
    (install) do_install; ret=$?; ;;
    (dev_setup) do_dev_setup; ret=$?; ;;
    (backup) do_backup; ret=$?; ;;
    (*) __error "Unknown command: ${cmd}"; usage; ;;
  esac;
  return ${ret};
};

main() {
  # Handle simple, self-contained commands that must run regardless of installation state.
  # They are called directly and exit immediately.
  case "$1" in
    (reset)
      if [[ "$2" == "-y" || "$2" == "--yes" ]]; then opt_yes=1; fi;
      do_reset; exit $?;
      ;;
    (install)
      do_install; exit $?;
      ;;
    (backup)
      do_backup; exit $?;
      ;;
    (dev_setup)
      if [[ "$2" == "-y" || "$2" == "--yes" ]]; then opt_yes=1; fi;
      do_dev_setup; exit $?;
      ;;
  esac;
  # If not installed, check for DEV_MODE or prompt the user.
  if [[ ! -f "${BOOKDB_DB_FILE}" ]]; then
    if [[ "${DEV_MODE}" == "true" ]]; then
      __log "DEV_MODE: Auto-installing on first run.";
      do_install;
    else
      local confirm_install;
      printf "BookDB appears to be uninstalled.\n" >&2;
      printf "Would you like to run the installer now? [y/N]: " >&2;
      read confirm_install;
      if [[ "${confirm_install}" == "y" || "${confirm_install}" == "Y" ]]; then
        do_install; exit $?;
      else
        __log "Installation cancelled by user. Exiting."; exit 1;
      fi;
    fi;
  fi;
  # Regular execution flow
  options "$@";
  if [[ -n "$opt_quiet" ]]; then QUIET_MODE=true; fi;
  # Handle commands that need DB but not context
  case "${ARGS[0]}" in
      (tables|tdump) dispatch; exit $?; ;;
  esac;
  # Handle all other commands that require context
  __resolve_context || exit 1;
  dispatch;
  local ret=$?;
  return ${ret};
};


#
# --- Execution Entry Point ---
#
main "$@";
