#!/usr/bin/env bash
#
# bookdb - Final MVP (Phase 5) with Full CRUD Functionality
# A shell-based, context-aware key-value store built on sqlite3.
#
# portable: sqlite3, sed, awk, grep, cut, rm, mkdir, cp, mv, chmod, readlink, date, tar, mktemp, dirname, basename, read
# builtins: printf, local, readonly, source, case, if, while, test, unset, shift, exit, echo, command, cat
#

  # @ top
  SELF="APP_BOOKDB";

  readonly BOOK_PREF='bookdb';
  readonly BOOK_NAME="$SELF";

  readonly BOOK_ARGS=("${@}");

  readonly BOOK_PPID="$$";
  readonly BOOK_PATH="$0";
  
  readonly APP_BOOKDB="${BASH_SOURCE[0]}";

  readonly TERM_WIDTH=$(tput cols 2>/dev/null || echo 80);




#-------------------------------------------------------------------------------
#  Flags
#-------------------------------------------------------------------------------

  # Do not use true or false, only 0 or 1.

  # --- Developer & Safety Toggles ---
  # Set DEV_MODE to true to bypass all [y/N] confirmation prompts.
  DEV_MODE=${DEV_MODE:-1};

  # Set SAFE_MODE to true to automatically back up the DB before destructive actions.
  SAFE_MODE=${SAFE_MODE:-0};

  # Add this near the other global toggles (this is auto do not edit)
  SAFE_BACKUP_PERFORMED=1;

  # Flag to block deep install or reset functions. Preserve Database
  SOFT_RESET=1;

  TEST_MODE=${TEST_MODE:-};

#-------------------------------------------------------------------------------
#  XDG+
#-------------------------------------------------------------------------------

  # ref: CHANGE TO BASHFX XDG
  _XDG_HOME="${HOME}/.local";
  _XDG_PREF="fx/${BOOK_PREF}";

  readonly BOOK_LIB="${_XDG_HOME}/lib/fx/app"; #special namespace for external apps

  readonly BOOK_BIN="${_XDG_HOME}/bin/fx";
  readonly BOOK_ETC="${_XDG_HOME}/etc/${_XDG_PREF}";

  # DO NOT CHANGE DATA!!!! WE DO NOT USE SHARE!  
  readonly BOOK_DATA="${_XDG_HOME}/data/${_XDG_PREF}"; # XDG data 

  readonly BOOK_STATE="${_XDG_HOME}/state/${_XDG_PREF}";
  readonly BOOK_CACHE="${HOME}/.cache/${_XDG_PREF}";

  readonly BOOK_RC="${BOOK_ETC}/bookrc";
  readonly BOOK_DB="${BOOK_DATA}/bookdb.sqlite"; #THIS_DB var is used instead now. select_db sets this.

  readonly BOOK_TEST_DB="${BOOK_DATA}/bookdb-test.sqlite"; 

  readonly BOOK_BASE_CURSOR="${BOOK_STATE}/base_cursor";
  readonly BOOK_CONTEXT_CURSOR="${BOOK_STATE}/context_cursor"; # Renaming for clarity


  readonly BOOK_LOCK="${BOOK_STATE}/db.lock";

#-------------------------------------------------------------------------------
#  Global Variables (Initialized by Bootstrap/Context)
#-------------------------------------------------------------------------------

# Global array to hold arguments after options are parsed.
ARGS=();

# Global context state variables
BOOK_PNS_ID=;
BOOK_PNS_NAME=;
BOOK_KVNS_ID=;
BOOK_KVNS_NAME=;

# --- New MDB Global State Variables ---
# These will be set by the context resolution logic.
THIS_BASE_NAME=;

# Global for pub/unpub operations
_PUB_KEY=;
_PUB_VALUE=;

LAST_FUNC=;
LAST_CMD=;

#-------------------------------------------------------------------------------
#  Escape
#-------------------------------------------------------------------------------


# Define some colors for clear output headers
  readonly  red2=$'\x1B[38;5;197m';
  readonly  red=$'\x1B[38;5;9m';
  readonly  deep=$'\x1B[38;5;61m';
  readonly  deep_green=$'\x1B[38;5;60m';
  readonly  orange=$'\x1B[38;5;214m';
  readonly  yellow=$'\x1B[33m';  

  readonly  green2=$'\x1B[32m';
  readonly  green=$'\x1B[38;5;10m';
  readonly  blue=$'\x1B[36m';
  readonly  blue2=$'\x1B[38;5;39m';
  readonly  cyan=$'\x1B[38;5;14m';
  readonly  magenta=$'\x1B[35m';  

  readonly  purple=$'\x1B[38;5;213m';
  readonly  purple2=$'\x1B[38;5;141m';
  readonly  white=$'\x1B[38;5;247m';
  readonly  white2=$'\x1B[38;5;15m';
  readonly  grey=$'\x1B[38;5;242m';
  readonly  grey2=$'\x1B[38;5;240m';
  readonly  grey3=$'\x1B[38;5;237m';
  readonly  xx=$'\x1B[0m'; 

  readonly LINE="$(printf '%.0s-' {1..54})";



################################################################################
#
#  stderr
#
################################################################################
# Description: Controls output based on QUIET_MODE and force parameter.
# Arguments:
#   1: msg (string) - The message to print.
#   2: force_output (string, optional) - Pass "force" to bypass QUIET_MODE.
# Returns: 0.
# Local Variables: msg, force_output
# Base printer function for stderr messages.
# Arguments:
#   1: msg (string) - The message to print.
#   2: force_output (string, optional) - Pass "force" to bypass QUIET_MODE (for error/fatal).
#   3: is_error_level (string, optional) - Pass "error" for error/fatal messages, to ensure they always go to stderr.
stderr(){
  local msg="$1";
  local force_output="$2";
  local is_error_level="$3"; # "error" if it's a fatal/error message

  # If in TEST_MODE and --printer stdoutt is active, and it's NOT an error/fatal message,
  # redirect output to stdoutt.
  if [[ "$TEST_MODE" -eq 0 && -n "$opt_printer_test" && -z "$is_error_level" ]]; then
    stdoutt "${msg}"; # Use stdoutt function for redirection
    return 0;
  fi

  # Otherwise (not in test override, or it's an error/fatal message),
  # follow normal stderr quietness rules.
  if [[ -z "$QUIET_MODE" ]] || [[ -n "$force_output" ]]; then
    printf "%b" "${msg}${xx}\n" 1>&2;
  fi
  return 0;
}

# New function: Prints directly to stdout (for test capture).
# Arguments:
#   1: msg (string) - The message to print.
stdoutt(){
  local msg="$1";
  printf "%b" "${msg}${xx}\n";
  return 0;
}

line(){ stderr "\n\n$grey3$LINE ($1)$xx\n"; }

COUNTER=".count_bookdb";
counter(){ local c=$(countx --name "$COUNTER"); printf "$c"; }

bar(){
  local len="${1:-54}"; local char="${2:O}";       # Default to '-' if no character is provided
  local line_str;
  printf -v line_str '%*s' "$len" '';
  line_str=${line_str// /${char}};

  # Use our stderr wrapper to print the final line
  stderr "$line_str";
  return 0;
}


#MORE_GLYPHS="☾☀︎⚁⚂⚅⚀☉✙✚✜♱⚙︎☩⚝☘︎⚑⚐☸︎🀸∇∞÷×∑∬≋&⊛⋈⋒⋓⋐⋑⨂⨹⨺⨻⩏⩛⩚⩓⟡⨳⩩⫷⫏⟐⟑⫶⟡⧊⧇⧈⧗⧖𝒆𝚫𝚲𝜟𝜳𝜰Ω℉℃₵¢€$▽△★☆✕✖︎✓✔︎❁✿✘✰✣☑︎☒◉⦿⇒➲⟿⇪⇧↩︎⟳↻⤬⥰⥼☻☺︎✍︎✌︎♈︎♂︎⚔︎⚉"
#MORE_GLYPHS2="⟿⟼☈☇☁︎⛵︎⚾︎✄♒︎♌︎♋︎♇⚕︎⚚§₽⨏⨍⨘⨜∏∽∾∿≈⋇⧚⧛⧍⧋⧌⧨⧪⅀𝞹𝝿𝝨𝝱𝝰𝝲𝝳𝝷𝝵𝝺𝞃𝞇𝞅𝞈𝚲𝕭⦼⦼⦻⦜⦛⦝⦨⫎⫐☈♜♛♚☕︎♌︎"
##☾⚯⚮⚭⚬☌⚲☉☍⚭∘∷∴⊚◎◉⦿◦✱❈※❆✻߷⚿⟐⮧  ⧖🗓

#߷⚿⟐⮧
#⎌ undo U+238C
#⟲ ⟳ redo U+27F2  ↩
# ↲” (U+21B2)
# “↯” (U+21AF)
# ↶ (U+21B6)
# ⏲ 23F2
# ⧖ 29D6
# 🗓 1F5D3
# ⏱ 23F1
# ⬎ 2B0E
# ↳ 21B3
# ↱ 21B1


fatal(){  stderr "${red}${*}" "force" "error"; exit 1; }
error(){ stderr "\t${red}└┄┄ ${*}" "force" "error"; }

warn(){  stderr  "\t${orange}└┄┄ ${*}"; }
okay(){  stderr  "\t${green}└┄┄ ${*}"; }
info(){  stderr  "\t${blue}└┄┄ ${*}"; }

log(){ stderr "${white2}${*}"; }

magic(){ is_dev && stderr "${purple}${*}" "force"; }

identify(){ is_dev && stderr "${grey}⟡┄┄┄[${white2}${FUNCNAME[1]}${grey}]"; }

trace(){ 
  is_dev || return 0;
  local f1="${FUNCNAME[1]}" f2="${FUNCNAME[2]}" f3="${FUNCNAME[3]}";
  local nl same lf1="$f1"; 
  local last="$LAST_CMD";

  [ -n "$LAST_FUNC" ] && [[ "$LAST_FUNC" == "$f1" ]] && { same=0; } || { same=1; }
  [ -n "$LAST_CMD" ] && last="\n${grey3}[${cyan}↯ $last${grey3}]" || last="";

  # [ -z "$f3" ] && f3="✻";
  [ -z "$f2" ]  || f1="${deep}$f1" && f2="${grey3}<-$f2";

  if [ "$same" -eq 0 ]; then
    str="\t${grey}└┄┄>>";
  else
    str="${last}${grey}\n⟡┄┄┄[$f1${grey}] $f2${grey} \n\t┆\n\t└┄┄>"; #\t└⚀\n

  fi


  stderr "  $str ${*}";

  LAST_FUNC="$lf1";

  #info "L: $LAST_FUNC 1: ${FUNCNAME[1]} ";
}

debug(){ is_dev && stderr "${cyan}${*}" "force"; }

dev(){ is_dev && stderr "\n${cyan}>>  [${deep}${FUNCNAME[1]}${cyan}]\n\t└┄┄ ${*} " "force"; }

devbar(){ is_dev && stderr "${cyan}⋈ [ DEV ] ${LINE}" "force"; }
devlog(){ is_dev && stderr "${cyan}⋈ [ DEV ] ${1}" "force"; }

imp(){ is_dev && stderr "${red2}⨹ IMP! ${x}${*}" "force"; }



#-------------------------------------------------------------------------------
#  STDFX Guards and Helpers
#-------------------------------------------------------------------------------

################################################################################
#
#  __is_empty
#
################################################################################
# Description: Checks if a string is empty or contains only whitespace.
# Arguments:
#   1: str (string) - The string to check.
# Returns: 0 (true) if empty/whitespace, 1 (false) otherwise.
__is_empty(){
  [[ -z "${1//[[:space:]]/}" ]];
  return $?; # Explicit return for clarity
}

################################################################################
#
#  is_empty
#
################################################################################
# Description: Checks if any of the given variable NAMES (not values) are empty
#              or contain only whitespace.
# Usage: is_empty "VAR_A" "VAR_B"
# Arguments:
#   @: var_name (string) - Names of variables to check.
# Returns: 0 (true) if at least one is empty/whitespace, 1 (false) otherwise.
is_empty(){
  local var_name;
  for var_name in "$@"; do
    if __is_empty "${!var_name}" ; then
      return 0; # Found an empty one, success (is_empty is true)
    fi
  done
  return 1; # None were empty, failure (is_empty is false)
}

################################################################################
#
#  is_defined
#
################################################################################
# Description: Checks if a given string has a non-empty, non-whitespace value.
# Arguments:
#   1: str (string) - The string to check.
# Returns: 0 (true) if defined, 1 (false) otherwise.
is_defined(){
  [[ -n "${1//[[:space:]]/}" ]];
  return $?;
}

################################################################################
#
#  is_file
#
################################################################################
# Description: Checks if a given path exists and is a regular file.
# Arguments:
#   1: path (string) - The path to check.
# Returns: 0 (true) if it's a file, 1 (false) otherwise.
is_file(){
  [ -n "$1" ] && test -f "$1";
  return $?;
}

################################################################################
#
#  is_chain
#
################################################################################
# Description: Checks if a given string starts with a context chain prefix
#              (@ or %).
# Arguments:
#   1: str (string) - The string to check.
# Returns: 0 (true) if it is a chain, 1 (false) otherwise.
is_chain(){
  # A valid context chain must start with @ or % AND contain a dot.
  [[ ("$1" == \@* || "$1" == \%*) && "$1" == *.* ]];
  return $?;
}

################################################################################
#
#  is_rw_filepath
#
################################################################################
# Description: Checks if a given file path is writable. This means the parent
#              directory is writable, and if the file itself exists, it must
#              also be writable.
# Arguments:
#   1: path (string) - The file path to check.
# Returns: 0 (true) if the path is writable, 1 (false) otherwise.
is_rw_filepath(){
  local path="$1";
  local dir;
  dir=$(dirname "${path}");
  if [[ ! -w "${dir}" ]]; then
    return 1;
  fi
  if [[ -e "${path}" && ! -w "${path}" ]]; then
    return 1;
  fi
  return 0;
}

################################################################################
#
#  is_rw_file
#
################################################################################
# Description: Checks if a given path exists and is a regular file that is
#              both readable and writable.
# Arguments:
#   1: path (string) - The path to check.
# Returns: 0 (true) if it's a readable/writable file, 1 (false) otherwise.
is_rw_file(){
  [ -n "$1" ] && test -f "$1" -a -r "$1" -a -w "$1";
  return $?;
}

################################################################################
#
#  is_name
#
################################################################################
# Description: Checks if ALL of the given variable NAMES have a non-empty value.
# Usage: is_name "VAR_A" "VAR_B"
# Arguments:
#   @: var_name (string) - Names of variables to check.
# Returns: 0 (true) if all have values, 1 (false) if any are empty.
is_name(){
  local var_name;
  for var_name in "$@"; do
    if [[ -z "${!var_name}" ]]; then
      return 1; # Found an empty one, failure
    fi
  done
  return 0; # All had values
}

################################################################################
#
#  is_integer
#
################################################################################
# Description: Checks if a given string is a valid integer (positive or negative).
# Arguments:
#   1: val (string) - The string to check.
# Returns: 0 (true) if it is an integer, 1 (false) otherwise.
is_integer(){
  local val="$1";
  # The regex checks for an optional leading hyphen, followed by one or more digits,
  # and nothing else from start (^) to end ($).
  [[ "${val}" =~ ^-?[0-9]+$ ]];
  return $?;
}

#-------------------------------------------------------------------------------
# Chad Functions (Dev/Debug)
#-------------------------------------------------------------------------------

################################################################################
#
#  noop
#
################################################################################
# Description: Simple no-operation command for testing options and flow.
#              Can be used to set context chain without explicit user command.
# Arguments:
#   1: msg (string) - Optional message to log.
# Returns: 0
noop(){
  [ -n "$1" ] && info "NOOP: [$1]";
  return 0;
}

################################################################################
#
#  noimp
#
################################################################################
# Description: Debug command for incomplete execution paths.
# Arguments:
#   1: msg (string) - Optional message.
# Returns: 1
noimp(){
  local msg="$1";
  local ctx;
  [ -n "$msg" ] && ctx="[$msg]";
  warn "NOIMP: ${FUNCNAME[1]} $ctx";
  return 1;
}

################################################################################
#
#  nosup
#
################################################################################
# Description: Debug command for unavailable features.
# Arguments:
#   1: msg (string) - Optional message.
# Returns: 1
nosup(){
  local msg="$1";
  local ctx;
  [ -n "$msg" ] && ctx="[$msg]";
  warn "NOSUP: ${FUNCNAME[1]} $ctx";
  return 1;
}

################################################################################
#
#  todo
#
################################################################################
# Description: Debug command for todo items.
# Arguments:
#   1: msg (string) - Optional message.
# Returns: 1
todo(){
  local msg="$1";
  local ctx;
  [ -n "$msg" ] && ctx="[$msg]";
  warn "TODO: ${FUNCNAME[1]} $ctx";
  return 1;
}

#-------------------------------------------------------------------------------
#  Core Internal Utilities
#-------------------------------------------------------------------------------

################################################################################
#
#  bootstrap
#
################################################################################
# Description: Initializes script environment, sources RC file if available.
# Returns: 0 on success, 1 on failure.
# Local Variables: ret
bootstrap(){
  local ret=1;
  if is_file "$BOOK_RC"; then
    source "$BOOK_RC";
    ret=$?;
  else
    noimp "ignore missing rc file, BOOK_PROJECT_HOME will be undefined or default";
    readonly BOOK_PROJECT_HOME="${BOOK_PROJECT_HOME:-$(dirname "$BOOK_PATH")}";
  fi
  if is_dev; then
    trace "Bookdb started from $BOOK_PATH";
    [ -n "$TEST_MODE" ] && magic "Test Mode is enabled. <stdoutt> is active with --pr flag.";
  fi
  return "$ret";
}

################################################################################
#
#  has_base
#
################################################################################
# Description: Checks if a database with the given name exists.
# Arguments:
#   1: base_name (string) - The name of the base to check for.
# Returns: 0 if the base exists, 1 otherwise.
has_base(){
    local base_name="$1";
    if __is_empty "${base_name}"; then return 1; fi
    
    # Use our existing, robust helper for this
    _list_bases | grep -q "^${base_name}$";
    return $?;
}

################################################################################
#
#  has_project
#
################################################################################
# Description: Checks if a project with the given name exists in the
#              CURRENTLY ACTIVE database.
# Arguments:
#   1: project_name (string) - The name of the project to check for.
# Returns: 0 if the project exists, 1 otherwise.
has_project(){
    local project_name="$1";
    if __is_empty "${project_name}"; then return 1; fi
    
    local project_id;
    project_id=$(__db_query "SELECT pns_id FROM project_ns WHERE pns_name = '${project_name}';");
    
    if __is_empty "${project_id}"; then
        return 1; # Does not exist
    fi
    return 0; # Exists
}

################################################################################
#
#  has_keystore
#
################################################################################
# Description: Checks if a keystore with the given name exists in the
#              CURRENTLY ACTIVE project and database.
# Arguments:
#   1: keystore_name (string) - The name of the keystore to check for.
# Returns: 0 if the keystore exists, 1 otherwise.
has_keystore(){
  local keystore_name="$1";
  if __is_empty "${keystore_name}"; then return 1; fi
  
  local keystore_id;
  keystore_id=$(__db_query "SELECT kvns_id FROM keyval_ns WHERE kvns_name = '${keystore_name}' AND pns_id_fk = ${BOOK_PNS_ID};" );
  
  if __is_empty "${keystore_id}"; then
      return 1; # Does not exist
  fi
  return 0; # Exists
}

################################################################################
#
#  has_key
#
################################################################################
# Description: Checks if a key with the given name exists in the
#              CURRENTLY ACTIVE keystore, project, and database.
# Arguments:
#   1: key_name (string) - The name of the key to check for.
# Returns: 0 if the key exists, 1 otherwise.
has_key(){
  local key_name="$1";
  if __is_empty "${key_name}"; then return 1; fi
  
  local key_value;
  key_value=$(__db_query "SELECT var_value FROM vars WHERE var_key = '${key_name}' AND kvns_id_fk = ${BOOK_KVNS_ID};" );
  
  # SQLite returns an empty string for a non-existent row, but also for a key
  # that exists with an empty value. `$?` is the key.
  # A successful query that returns 0 rows will still exit with 0.
  # We need to check if the output is empty AND the query was successful.
  if [[ $? -eq 0 && -n "$key_value" ]]; then
      return 0; # Exists and has a value
  elif [[ $? -eq 0 && -z "$key_value" ]]; then
      # This is ambiguous. Does an empty value mean it exists? For `has_key`, yes.
      # To be certain, we should query for the ID.
      local key_id=$(__db_query "SELECT var_id FROM vars WHERE var_key = '${key_name}' AND kvns_id_fk = ${BOOK_KVNS_ID};" );
      if __is_empty "${key_id}"; then return 1; else return 0; fi
  fi
  return 1; # Query failed for some reason
}

################################################################################
#
#  select_db
#
################################################################################
# Description: Sets the active database for the current command execution based on
#              TEST_MODE or the persisted base cursor.
# Sets Global: THIS_DB, THIS_BASE_NAME
# Returns: 0
select_db(){
  # Priority 1: TEST_MODE always overrides everything.
  if [[ -n "$TEST_MODE" && "$TEST_MODE" -eq 0 ]]; then
    THIS_DB="$BOOK_TEST_DB";
    THIS_BASE_NAME="test";
    return 0;
  fi

  # Priority 2: Read the active base name from the cursor file.
  local base_name;
  if [[ -f "${BOOK_BASE_CURSOR}" ]]; then
    base_name=$(cat "${BOOK_BASE_CURSOR}");
  fi

  # Priority 3: If cursor is empty, file doesn't exist, or the DB file is missing,
  # default to "main".
  if __is_empty "${base_name}" || [[ ! -f "$(__get_base_path "${base_name}")" ]]; then
    base_name="main";
  fi

  # Set the global variables based on the resolved name.
  THIS_BASE_NAME="${base_name}";
  THIS_DB=$(__get_base_path "${THIS_BASE_NAME}");
  return 0;
}
################################################################################
#
#  is_super_context (New Guard Function)
#
################################################################################
# Description: Checks if the target context is the indestructible GLOBAL.VAR.main.
is_super_context(){
    local pns_name="$1";
    local kvns_name="$2";
    if [[ "${pns_name}" == "GLOBAL" && "${kvns_name}" == "MAIN" ]]; then
        return 0;
    else
        return 1;
    fi
}

################################################################################
#
#  __ensure_default_keystore_exists (New Low-Ordinal Helper)
#
################################################################################
# Description: Self-healing function to enforce the indestructible GLOBAL.VAR.main rule.
#              Ensures the core project and keystore exist in the current database.
__ensure_default_keystore_exists(){
    # Ensure THIS_DB is set before running queries
    if __is_empty "${THIS_DB}"; then
        error "FATAL: __ensure_default_keystore_exists called before THIS_DB was set.";
        return 1;
    fi

    local global_pns_id;
    global_pns_id=$(__db_query "SELECT pns_id FROM project_ns WHERE pns_name = 'GLOBAL';" );
    if [[ -z "${global_pns_id}" ]]; then
        __db_query "INSERT INTO project_ns (pns_name) VALUES ('GLOBAL');";
        global_pns_id=$(__db_query "SELECT pns_id FROM project_ns WHERE pns_name = 'GLOBAL';" );
    fi

    if [[ -z "${global_pns_id}" ]]; then
        error "FATAL: Could not create or find GLOBAL project in ${THIS_DB}.";
        return 1;
    fi

    local main_kvns_id;
    main_kvns_id=$(__db_query "SELECT kvns_id FROM keyval_ns WHERE kvns_name = 'MAIN' AND pns_id_fk = ${global_pns_id};" );
    if [[ -z "${main_kvns_id}" ]]; then
        __db_query "INSERT INTO keyval_ns (kvns_name, pns_id_fk) VALUES ('MAIN', ${global_pns_id});";
    fi
    return 0;
}

################################################################################
#
#  __ensure_default_base_exists (New Low-Ordinal Helper)
#
################################################################################
# Description: Self-healing function to ensure the default 'main.sqlite' base
#              exists. If it doesn't, it creates it.
__ensure_default_base_exists(){
    local main_base_path;
    main_base_path=$(__get_base_path "main");

    if [[ ! -f "${main_base_path}" ]]; then
        info "Default 'main' database not found. Creating it now...";
        # Use our existing low-level helper to create and initialize it.
        _create_base "main" || fatal "FATAL: Could not create the default 'main' database.";
    fi
    return 0;
}

__require_invincible_defaults(){
  if __ensure_default_base_exists; then
    __ensure_default_keystore_exists && return 0;
  fi
  fatal "Required default base and tables cannot be ensured!";
}


################################################################################
#
#  is_dev
#
################################################################################
# Description: Checks if DEV_MODE is enabled (0).
# Returns: 0 (true) if DEV_MODE is 0, 1 (false) otherwise.
is_dev(){
  [ -n "$DEV_MODE" ] && [ "$DEV_MODE" -eq 0 ];
  return $?;
}

################################################################################
#
#  is_user
#
################################################################################
# Description: Checks if user mode is enabled (DEV_MODE is not 0).
# Returns: 0 (true) if DEV_MODE is not 0, 1 (false) otherwise.
is_user(){
  [ -z "$DEV_MODE" ] || [ "$DEV_MODE" -eq 1 ];
  return $?;
}

################################################################################
#
#  require_safe
#
################################################################################
# Description: Checks if SAFE_MODE is enabled (0).
# Returns: 0 (true) if SAFE_MODE is 0, 1 (false) otherwise.
require_safe(){
  [ -n "$SAFE_MODE" ] && [ "$SAFE_MODE" -eq 0 ];
  return $?;
}

################################################################################
#
#  dev_rc
#
################################################################################
# Description: Prints the content of the bookdb RC file if in dev mode.
# Returns: 0 if printed or file doesn't exist, 1 otherwise.
dev_rc(){
  is_dev && is_file "$BOOK_RC" && cat "$BOOK_RC";
  return $?;
}

################################################################################
#
#  __sed_in_place
#
################################################################################
# Description: Atomically applies a sed script to a file.
# Arguments:
#   1: sed_script (string) - The sed script to apply.
#   2: target_file (string) - The file to modify.
# Returns: 0 on success, 1 on failure.
# Local Variables: sed_script, target_file, tmp_file
__sed_in_place(){
  local sed_script="$1";
  local target_file="$2";
  local tmp_file;
  local ret=1;

  if [[ ! -f "${target_file}" || ! -w "${target_file}" ]]; then
      error "File not found or not writable for sed in-place edit: ${target_file}";
      return 1;
  fi

  tmp_file=$(mktemp);
  if [[ $? -ne 0 ]]; then
      error "Failed to create temp file for in-place edit.";
      return 1;
  fi

  if ! sed "${sed_script}" "${target_file}" > "${tmp_file}"; then
      error "sed command failed while processing ${target_file}";
      rm -f "${tmp_file}"; # Clean up the temp file on failure
      return 1;
  fi

  if ! mv "${tmp_file}" "${target_file}"; then
      error "Failed to move temp file to overwrite ${target_file}";
      return 1;
  fi

  return 0;
}

################################################################################
#
#  __validate_name
#
################################################################################
# Description: Validates if a string is a valid name for a key or namespace.
#              (Rule: No dots allowed).
# Arguments:
#   1: name_to_check (string) - The name to validate.
#   2: name_type (string) - A descriptive label for the name (e.g., "Key").
# Returns: 0 (true) if valid, 1 (false) otherwise.
# Local Variables: name_to_check, name_type
__validate_name(){
  local name_to_check="$1";
  local name_type="$2"; # e.g., "Key", "Project Name"

  if [[ "${name_to_check}" =~ \. ]]; then
    error "Invalid ${name_type}: '${name_to_check}'. Dots (.) are not allowed in names.";
    return 1;
  fi
  
  if ! [[ "${name_to_check}" =~ ^[a-zA-Z0-9_-]+$ ]]; then
    error "Invalid ${name_type}: '${name_to_check}'. Only alphanumeric characters, underscores (_), and hyphens (-) are allowed.";
    return 1;
  fi

  return 0;
}

################################################################################
#
#  __get_base_path (Low-Ordinal)
#
################################################################################
# Description: Takes a base name and returns its full, absolute path.
__get_base_path(){
    local base_name="$1";
    printf "%s" "${BOOK_DATA}/${base_name}.sqlite";
    return 0;
}

################################################################################
#
#  _list_bases (Mid-Ordinal)
#
################################################################################
# Description: Safely lists the names of all existing databases.
# Risk R-01: Must use a safe globbing loop, not ls.
_list_bases(){
    for db_file in "${BOOK_DATA}"/*.sqlite; do
      if [[ -f "$db_file" ]]; then # Check if glob found a file
        basename "${db_file%.sqlite}";
      fi
    done
    return 0;
}

################################################################################
#
#  _create_base (Mid-Ordinal)
#
################################################################################
# Description: Creates and initializes a new database file.
_create_base(){
    local base_name="$1";
    local base_path;
    base_path=$(__get_base_path "$base_name");

    # System-level guard: check if file already exists
    if [[ -f "${base_path}" ]]; then
        error "Database '${base_name}' already exists at: ${base_path}";
        return 1;
    fi

    # System-level guard: check if path is writable
    if ! is_rw_filepath "${base_path}"; then
        error "Cannot create database: Path is not writable: '${base_path}'.";
        return 1;
    fi

    touch "${base_path}" || { error "Failed to create database file: ${base_path}"; return 1; };
    
    # Temporarily override THIS_DB to initialize the new base
    local original_this_db="${THIS_DB}";
    THIS_DB="${base_path}";
    __setup_sql; # Create schema in the new database
    local ret=$?;
    THIS_DB="${original_this_db}"; # Restore original THIS_DB
    
    if [[ $ret -eq 0 ]]; then
      okay "Database '${base_name}' created and initialized successfully.";
    fi
    return ${ret};
}

################################################################################
#
#  _remove_base (Mid-Ordinal)
#
################################################################################
# Description: Deletes a database file. Contains no user-level safety.
_remove_base(){
    local base_name="$1";
    local base_path;
    base_path=$(__get_base_path "$base_name");

    # System-level guard: check if file exists
    if [[ ! -f "${base_path}" ]]; then
        error "Database '${base_name}' does not exist.";
        return 1;
    fi

    rm -f "${base_path}" "${base_path}-wal" "${base_path}-shm" || { error "Failed to remove database files for: ${base_name}"; return 1; };
    okay "Database '${base_name}' removed.";
    return 0;
}
################################################################################
#
#  __db_query
#
################################################################################
# Description: Executes an SQLite query against the active database.
################################################################################
#
#  __db_query (Corrected and Robust)
#
################################################################################
# Description: Executes a concurrency-safe SQLite query using flock, running
#              the command only once for efficiency and correctness.
# Arguments:
#   1: query (string) - The SQL query to execute.
#   @: additional_sqlite3_args (string) - Any arguments to pass directly to sqlite3.
# Returns: Exit status of sqlite3. Prints query results to stdout.
__db_query(){
  local query="$1";
  shift;
  
  if ! command -v sqlite3 >/dev/null 2>&1; then
    error "sqlite3 command not found.";
    return 1;
  fi;
  if [[ ! -f "${THIS_DB}" ]]; then
    error "Database file does not exist: ${THIS_DB}.";
    return 1;
  fi;
  touch "${BOOK_LOCK}" || { error "Could not create or touch lock file: ${BOOK_LOCK}"; return 1; };

  # This subshell ensures the lock is acquired before execution and released upon exit.
  (
    flock -x 200;
    
    local output;
    local ret;

    # Execute sqlite3 ONCE, capturing its combined output and exit code.
    # On success, sqlite3's stderr is typically empty.
    # On failure, its stdout is typically empty.
    output=$(sqlite3 "$@" "${THIS_DB}" "${query}" 2>&1);
    ret=$?;

    if [[ ${ret} -ne 0 ]]; then
      # If the command failed, the captured `output` is the error message.
      printf "%b\n" "${red}DB query failed for: ${query}${xx}" >&2;
      printf "%b\n" "${red}SQLite Error: ${output}${xx}" >&2;
    else
      # If the command succeeded, the captured `output` is the data.
      # We strip the single trailing newline before printing to our stdout.
      printf "%s" "${output%$\n}";
    fi;
    
    exit ${ret};
  ) 200>"${BOOK_LOCK}";
  
  return $?;
}


################################################################################
#
#  __persist_cursor
#
################################################################################
# Description: Writes the current Project and Key-Value Namespace names to the
#              cursor file for persistence across sessions.
__persist_cursor(){
  local pns_name="$1";
  local kvns_name="$2";
  if [[ -z "$pns_name" || -z "$kvns_name" ]]; then
    error "Cannot persist invalid cursor (PNS: '${pns_name}', KVNS: '${kvns_name}').";
    return 1;
  fi
  printf "%s\n%s\n" "${pns_name}" "${kvns_name}" > "${BOOK_CONTEXT_CURSOR}" || fatal "Failed to write context cursor file: ${BOOK_CONTEXT_CURSOR}";
  return 0;
}

################################################################################
#
#  __backup_db
#
################################################################################
# Description: Performs a daily automatic backup of the database if SAFE_MODE
#              is enabled and no backup has been performed yet today.
__backup_db(){
  if [[ "${SAFE_MODE}" -ne 0 || "${SAFE_BACKUP_PERFORMED}" -eq 0 ]]; then
    return 0;
  fi
  if [[ ! -f "${THIS_DB}" ]]; then
    trace "SAFE_MODE: Database does not exist, skipping backup.";
    return 0;
  fi

  local today; today=$(date +%Y-%m-%d);
  local backup_dir="${BOOK_DATA}/backups";
  local daily_backup_file="${backup_dir}/bookdb-auto-backup-${today}.tar.gz";

  SAFE_BACKUP_PERFORMED=0;

  if [[ -f "${daily_backup_file}" ]]; then
    trace "SAFE_MODE: Daily auto-backup for ${today} already exists.";
    return 0;
  fi
  
  mkdir -p "${backup_dir}" || error "Could not create backup directory: ${backup_dir}.";
  trace "SAFE_MODE: Performing daily auto-backup to ${daily_backup_file}";
  # We only back up the database file for the automatic safety backup
  tar -czf "${daily_backup_file}" -C "$(dirname "${THIS_DB}")" "$(basename "${THIS_DB}")";

  if [[ $? -ne 0 ]]; then
    error "Auto-backup failed!";
    return 1;
  fi
  return 0;
}

################################################################################
#
#  __confirm_action
#
################################################################################
# Description: Prompts the user for confirmation before proceeding with an action.
__confirm_action(){
  local prompt_msg="$1";
  if is_dev; then
    dev "DEV_MODE: Auto-confirming action.";
    return 0;
  fi
  if [[ -n "$opt_yes" ]]; then
    return 0;
  fi
  local confirm;
  printf "${yellow}%s${xx} [y/N]: " "${prompt_msg}" >&2;
  read -r confirm;
  if [[ "${confirm}" == "y" || "${confirm}" == "Y" ]]; then
    return 0;
  else
    return 1;
  fi
}

################################################################################
#
#  __resolve_context
#
################################################################################
# Description: Resolves the active context based on command-line overrides or
#              persisted cursors, enforcing Context Atomicity.
# __resolve_context_orig(){
#   trace "Attempting to resolve context...";
#   local ret=1;
#   local T_base_name=;
#   local T_pns_name=;
#   local T_kvns_name=;
#   local persist_base_needed=0;
#   local persist_context_needed=0;
  
#   # 1. Handle base override from `options()`
#   if [[ -n "${opt_base_override}" ]]; then
#       T_base_name="${opt_base_override}";
#       if [[ "${opt_chain_mode}" == "@" ]]; then
#         persist_base_needed=1;
#         persist_context_needed=1; # Persist both if base is being changed with @
#       fi

#       # Validate that base_name exists
#       local found_base=0;
#       for base in $(_list_bases); do
#         [[ "${base}" == "${T_base_name}" ]] && { found_base=1; break; }
#       done
#       if [[ "${found_base}" -eq 0 ]]; then
#         error "Base '${T_base_name}' not found.";
#         return 1;
#       fi
#       # Set THIS_DB and THIS_BASE_NAME for this command
#       THIS_BASE_NAME="${T_base_name}";
#       THIS_DB=$(__get_base_path "${THIS_BASE_NAME}");
#   else
#       # If no base override, rely on the active base already set by select_db()
#       T_base_name="${THIS_BASE_NAME}";
#   fi

#   # 2. Handle context chain from `options()` or --flags
#   if [[ -n "${opt_context_chain}" ]]; then
#     local chain_parts=($(echo "${opt_context_chain}" | cut -d'.' -f1,3 --output-delimiter=' '));
#     T_pns_name="${chain_parts[0]}";
#     T_kvns_name="${chain_parts[1]}";
#     if [[ -z "${chain_parts[1]}" ]]; then # Handle case like `base@project` -> reset to main
#         T_kvns_name="MAIN";
#     fi
#   elif [[ -n "${opt_projdb}" ]]; then # Handle --projdb flag
#     persist_context_needed=1;
#     T_pns_name="${opt_projdb}";
#     T_kvns_name="MAIN"; # Context Atomicity: reset keystore to main
#   elif [[ -n "${opt_keydb}" && -z "${opt_projdb}" ]]; then # Handle --keydb flag without --projdb
#     persist_context_needed=1;
#     T_pns_name="${BOOK_PNS_NAME}"; # Use current project
#     T_kvns_name="${opt_keydb}";
#   fi
  
#   # 3. If no context specified via flags/chain, use persisted cursor
#   if __is_empty "${T_pns_name}" && __is_empty "${T_kvns_name}"; then
#     if [[ -f "${BOOK_CONTEXT_CURSOR}" ]]; then
#       T_pns_name=$(sed -n '1p' "${BOOK_CONTEXT_CURSOR}");
#       T_kvns_name=$(sed -n '2p' "${BOOK_CONTEXT_CURSOR}");
#     else # Default to GLOBAL.MAIN if all else fails
#       T_pns_name="GLOBAL";
#       T_kvns_name="MAIN";
#     fi
#   fi

#   trace "Context proposal: Base: '${T_base_name}' PNS: '${T_pns_name}' KVNS: '${T_kvns_name}'";

#   # 4. Validate and commit context
#   if __is_empty "${T_pns_name}" || __is_empty "${T_kvns_name}"; then
#     error "Failed to resolve a valid Project or Key-Value Namespace.";
#     return 1;
#   fi
  
#   local pns_name_sql="${T_pns_name//\'/\'\'}";
#   local kvns_name_sql="${T_kvns_name//\'/\'\'}";
  
#   local T_pns_id=$(__db_query "SELECT pns_id FROM project_ns WHERE pns_name = '${pns_name_sql}';" | tr -d '\n');
#   if [[ -z "${T_pns_id}" ]]; then
#     error "Project Namespace not found: '${T_pns_name}'.";
#     return 1;
#   }

#   local T_kvns_id=$(__db_query "SELECT kvns_id FROM keyval_ns WHERE kvns_name = '${kvns_name_sql}' AND pns_id_fk = ${T_pns_id};" | tr -d '\n');
#   if [[ -z "${T_kvns_id}" ]]; then
#     error "Key-Value Namespace not found: '${T_kvns_name}' in project '${T_pns_name}'.";
#     return 1;
#   }

#   # Set global context variables
#   BOOK_PNS_ID="${T_pns_id}";
#   BOOK_PNS_NAME="${T_pns_name}";
#   BOOK_KVNS_ID="${T_kvns_id}";
#   BOOK_KVNS_NAME="${T_kvns_name}";
  
#   if [[ ${persist_context_needed} -eq 1 ]]; then
#     log "Persisting new context to cursor: '${BOOK_PNS_NAME}.VAR.${BOOK_KVNS_NAME}'";
#     __persist_cursor "${BOOK_PNS_NAME}" "${BOOK_KVNS_NAME}";
#   fi

#   if [[ ${persist_base_needed} -eq 1 ]]; then
#     log "Persisting new base to cursor: '${THIS_BASE_NAME}'";
#     printf "%s" "${THIS_BASE_NAME}" > "${BOOK_BASE_CURSOR}" || fatal "Failed to write base cursor file: ${BOOK_BASE_CURSOR}";
#   fi

#   trace "Context resolved: ${THIS_BASE_NAME}@${BOOK_PNS_NAME}.VAR.${BOOK_KVNS_NAME}";
#   return 0;
# }

__correct_context(){
  local def_pns_name="GLOBAL";
  local def_kvns_name="MAIN";
  #__persist_cursor;
}


################################################################################
#
#  __resolve_context (Corrected)
#
################################################################################
# Description: The central nervous system for context resolution.
__resolve_context(){
    trace "Attempting to resolve context...";
    local T_base_name="${THIS_BASE_NAME}";
    local T_pns_name=; local T_kvns_name=;
    local persist_base=0; local persist_context=0;
    local context_from_cmd=0;

    # --- Part 1: Prioritize command-line overrides ---
    if [[ -n "$opt_base_override" ]]; then
        context_from_cmd=1;
        if ! _list_bases | grep -q "^${opt_base_override}$"; then error "Base '${opt_base_override}' not found."; return 1; fi
        T_base_name="${opt_base_override}";
        if [[ "${opt_chain_mode}" == "@" ]]; then persist_base=1; fi
    fi

    # Commit the base for this run so DB queries below are correct
    THIS_BASE_NAME="${T_base_name}";
    THIS_DB=$(__get_base_path "${THIS_BASE_NAME}");

    if [[ -n "$opt_projdb" ]]; then
        context_from_cmd=1; persist_context=1;
        T_pns_name="${opt_projdb}"; T_kvns_name="MAIN";
    elif [[ -n "$opt_context_chain" ]]; then
        context_from_cmd=1;
        if [[ "${opt_context_chain}" == *".VAR."* ]]; then
            T_pns_name="${opt_context_chain%%.VAR.*}";
            T_kvns_name="${opt_context_chain#*.VAR.}";
        else
            T_pns_name="${opt_context_chain%%.*}"; T_kvns_name="MAIN";
        fi
        if [[ "${opt_chain_mode}" == "@" ]]; then persist_context=1; fi
    fi

    # --- Part 2: Fallback to Cursor Files ---
    if [[ $context_from_cmd -eq 0 ]]; then
        if [[ -f "${BOOK_CONTEXT_CURSOR}" ]]; then
            T_pns_name=$(sed -n '1p' "${BOOK_CONTEXT_CURSOR}");
            T_kvns_name=$(sed -n '2p' "${BOOK_CONTEXT_CURSOR}");
        fi
    fi
    
    # --- Part 3: Final Defaulting and Validation ---
    if __is_empty "${T_pns_name}"; then T_pns_name="GLOBAL"; fi
    if __is_empty "${T_kvns_name}"; then T_kvns_name="MAIN"; fi
    
    local pns_id=$(__db_query "SELECT pns_id FROM project_ns WHERE pns_name = '${T_pns_name}';" );
    if __is_empty "$pns_id"; then error "Project '${T_pns_name}' not found in base '${THIS_BASE_NAME}'."; return 1; fi
    local kvns_id=$(__db_query "SELECT kvns_id FROM keyval_ns WHERE kvns_name = '${T_kvns_name}' AND pns_id_fk = ${pns_id};" );
    if __is_empty "$kvns_id"; then error "Keystore '${T_kvns_name}' not found in project '${T_pns_name}'."; return 1; fi

    # --- Part 4: Commit to Globals and Persist Cursors ---
    BOOK_PNS_ID="$pns_id"; BOOK_PNS_NAME="$T_pns_name";
    BOOK_KVNS_ID="$kvns_id"; BOOK_KVNS_NAME="$T_kvns_name";

    if [[ $persist_base -eq 1 ]]; then
        info "Persisting new base to cursor: '${THIS_BASE_NAME}'";
        printf "%s" "${THIS_BASE_CURSOR}" > "${BOOK_BASE_CURSOR}";
    fi

    if [[ $persist_context -eq 1 ]]; then
        info "Persisting new context to cursor: '${BOOK_PNS_NAME}.VAR.${BOOK_KVNS_NAME}'";
        __persist_cursor "${BOOK_PNS_NAME}" "${BOOK_KVNS_NAME}";
    fi

    trace "Context resolved: ${THIS_BASE_NAME}@${BOOK_PNS_NAME}.VAR.${BOOK_KVNS_NAME}";
    return 0;
}

################################################################################
#
#  __write_keystore_to_file
#
################################################################################
# Description: Generates and writes configuration content to a specified file.
__write_keystore_to_file(){
  local pns_name="$1"; local kvns_name="$2"; local target_file="$3";

  local pns_id=$(__db_query "SELECT pns_id FROM project_ns WHERE pns_name = '${pns_name//\'/\'\'}";" );
  local kvns_id=$(__db_query "SELECT kvns_id FROM keyval_ns WHERE kvns_name = '${kvns_name//\'/\'\'}' AND pns_id_fk = ${pns_id};" );

  if [[ -z "${kvns_id}" ]]; then
    error "Internal error: Could not find ID for ${pns_name}/${kvns_name}.";
    return 1;
  fi

  local header_content;
  printf -v header_content "# bookdb export for keystore: %s in project: %s\n_BOOKDB_CHAIN_=@%s.VAR.%s\n_BOOKDB_WRITEMODE_=overwrite\n\n" \
    "${kvns_name}" "${pns_name}" "${pns_name}" "${kvns_name}";
  printf "%s" "${header_content}" > "${target_file}";

  if [[ $? -ne 0 ]]; then error "Failed to write header to file: ${target_file}"; return 1; fi

  local sql="SELECT var_key, var_value FROM vars WHERE kvns_id_fk = ${kvns_id} ORDER BY var_key;";
  local results=$(__db_query "${sql}" "-separator" "|");
  if [[ $? -ne 0 ]]; then error "Failed to retrieve variables for export."; return 1; fi
  
  if [[ -n "${results}" ]]; then
    echo "${results}" | while IFS="|" read -r key value; do
      printf '%s="%s"\n' "${key}" "${value}" >> "${target_file}";
    done
  fi
  
  return 0;
}

################################################################################
#
#  __find_shell_profile
#
################################################################################
# Description: Attempts to find the user's primary shell profile file.
__find_shell_profile(){
  if is_file "$HOME/.bashrc"; then
    printf "%s" "$HOME/.bashrc";
  elif is_file "$HOME/.zshrc"; then
    printf "%s" "$HOME/.zshrc";
  elif is_file "$HOME/.profile"; then
    printf "%s" "$HOME/.profile";
  else
    return 1;
  fi
  return 0;
}

################################################################################
#
#  __link_to_profile
#
################################################################################
# Description: Adds a source line for the bookdb RC file to the user's shell profile.
__link_to_profile(){
  local profile_file="$1";
  local link_line_content="$2";
  local ret=1;

  if [[ ! -f "${profile_file}" ]]; then
    error "Shell profile not found: ${profile_file}. Cannot link RC file.";
    return 1;
  fi

  if grep -qF -- "${link_line_content}" "${profile_file}" 2>/dev/null; then
    trace "Profile link found '${profile_file}'.";
    return 0;
  else
    trace "Adding bookdb configuration to '${profile_file}'...";
    printf "\n%s\n" "${link_line_content}" >> "${profile_file}";
    ret=$?;
    if [[ ${ret} -ne 0 ]]; then
      error "Failed to add link to profile: ${profile_file}. Permission denied?";
    fi
  fi
  return "${ret}";
}

################################################################################
#
#  __unlink_from_profile
#
################################################################################
# Description: Removes the bookdb source line from the user's shell profile.
__unlink_from_profile(){
  local profile_file="$1";
  local sentinel_comment="# bookdb configuration";
  local ret=0;

  if [[ ! -f "${profile_file}" ]]; then
    trace "Profile file not found: ${profile_file}. Nothing to unlink.";
    return 0;
  }

  if grep -qF -- "${sentinel_comment}" "${profile_file}" 2>/dev/null; then
      trace "Removing bookdb configuration from '${profile_file}'...";
      local sed_script="/${sentinel_comment}/d";
      __sed_in_place "${sed_script}" "${profile_file}";
      ret=$?;
  fi
  return "${ret}";
}

# --- Command Functions (Business Logic) ---


################################################################################
#
#  __print_keystore_contents
#
################################################################################
# Description: Queries and prints all key-value pairs for a given keystore.
__print_keystore_contents(){
  local pns_name="$1"; local kvns_name="$2";
  local pns_name_sql="${pns_name//\'/\'\'}";
  local kvns_name_sql="${kvns_name//\'/\'\'}";
  local sql="SELECT v.var_key, v.var_value FROM vars v JOIN keyval_ns k ON v.kvns_id_fk = k.kvns_id JOIN project_ns p ON k.pns_id_fk = p.pns_id WHERE p.pns_name = '${pns_name_sql}' AND k.kvns_name = '${kvns_name_sql}' ORDER BY v.var_key;";
  local results=$(__db_query "${sql}" "-separator" "|");

  if [[ -z "${results}" ]]; then
      printf "      (empty)\n" >&2;
  else
      echo "${results}" | while IFS="|" read -r key value; do
          printf "    - %s = %s\n" "${key}" "${value}" >&2;
      done
  fi
  return 0;
}



################################################################################
#
#  do_ls
#
################################################################################
# Description: Lists various database entities.
do_ls(){
  local ret=1;
  local what="${1:-keys}"; # Default to listing keys
  case "${what}" in
    (all) do_ls_all; ret=$?; ;;
    (bases)
      local all_bases;
      all_bases=$(_list_bases);
      if __is_empty "${all_bases}"; then
          info "No bases found.";
      else
          info "Available Bases!";
          echo "${all_bases}" | while IFS= read -r base_name; do
              local prefix="  ";
              if [[ "${base_name}" == "${THIS_BASE_NAME}" ]]; then
                  prefix="* ";
              fi
              info "${prefix}${base_name}";
          done;
      fi
      ret=0;
      ;;
    (project)
      __db_query "SELECT pns_name FROM project_ns ORDER BY pns_name;"; ret=$?; ;;
    (vars)
      local sql="SELECT kvns_name FROM keyval_ns WHERE pns_id_fk = ${BOOK_PNS_ID} ORDER BY kvns_name;";
      __db_query "${sql}"; ret=$?; ;;
    (keys)
      trace "Listing keys in active cursor: @${BOOK_PNS_NAME}.VAR.${BOOK_KVNS_NAME}";
      local sql="SELECT var_key FROM vars WHERE kvns_id_fk = ${BOOK_KVNS_ID} ORDER BY var_key;";
      __db_query "${sql}"; ret=$?; ;;
    (*)
      error "Invalid argument for 'ls'. Use 'all', 'bases', 'project', 'vars', or 'keys'.";
      return 1;
      ;;
  esac
  return "${ret}";
}


################################################################################
#
#  do_getv
#
################################################################################
# Description: Retrieves and prints the value of a variable to stdout.
do_getv(){
  local key="$1";
  if __is_empty "${key}"; then error "Usage: bookdb getv <KEY>"; return 1; fi
  __validate_name "${key}" "Key" || return 1;
  local key_sql="${key//\'/\'\'}";
  local sql="SELECT var_value FROM vars WHERE var_key = '${key_sql}' AND kvns_id_fk = ${BOOK_KVNS_ID};";
  __db_query "${sql}";
  return $?;
}

################################################################################
#
#  do_setv
#
################################################################################
# Description: Creates or updates a variable in the active context.
do_setv(){
  local arg="$1";
  local key="${arg%%=*}"; local val="${arg#*=}";
  if __is_empty "$key" || [[ "$arg" == "$key" ]]; then error "Usage: bookdb setv <KEY=VALUE>"; return 1; fi
  __validate_name "${key}" "Key" || return 1;
  local key_sql="${key//\'/\'\'}"; local val_sql="${val//\'/\'\'}";
  local ts=$(date +%s);
  local var_id=$(__db_query "SELECT var_id FROM vars WHERE var_key = '${key_sql}' AND kvns_id_fk = ${BOOK_KVNS_ID};" | tr -d '\n');
  
  if __is_empty "${var_id}"; then
    info "New Variable: '${key}' in @${BOOK_PNS_NAME}.VAR.${BOOK_KVNS_NAME}";
    local sql_insert="INSERT INTO vars (var_key, var_value, var_updated, kvns_id_fk) VALUES ('${key_sql}', '${val_sql}', ${ts}, ${BOOK_KVNS_ID});";
    __db_query "${sql_insert}";
  else
    trace "Updating existing variable: '${key}' in @${BOOK_PNS_NAME}.VAR.${BOOK_KVNS_NAME}";
    local sql_update="UPDATE vars SET var_value = '${val_sql}', var_updated = ${ts} WHERE var_id = ${var_id};";
    __db_query "${sql_update}";
  fi
  return $?;
}

################################################################################
#
#  do_delv
#
################################################################################
# Description: Deletes a variable from the active context after confirmation.
do_delv(){
  local key="$1";
  if __is_empty "${key}"; then error "Usage: bookdb delv <KEY>"; return 1; fi
  __validate_name "${key}" "Key" || return 1;
  if __confirm_action "Delete variable '${key}' from context '@${BOOK_PNS_NAME}.VAR.${BOOK_KVNS_NAME}'?"; then
    local key_sql="${key//\'/\'\'}";
    __backup_db || return 1;
    __db_query "DELETE FROM vars WHERE var_key = '${key_sql}' AND kvns_id_fk = ${BOOK_KVNS_ID};";
    if [[ $? -eq 0 ]]; then okay "Deleted variable: ${key}"; return 0; fi
  fi
  trace "Deletion cancelled or failed.";
  return 1;
}

################################################################################
#
#  do_find
#
################################################################################
# Description: Finds keys across all projects/keystores matching a pattern.
do_find(){
  local key_pattern="$1";
  if __is_empty "${key_pattern}"; then error "Usage: bookdb find <KEY_PATTERN>"; return 1; fi
  [[ "$key_pattern" != *"%"* ]] && key_pattern="%${key_pattern}%";
  local key_sql="${key_pattern//\'/\'\'}";
  local sql="SELECT p.pns_name, k.kvns_name, v.var_key FROM vars v JOIN keyval_ns k ON v.kvns_id_fk = k.kvns_id JOIN project_ns p ON k.pns_id_fk = p.pns_id WHERE v.var_key LIKE '${key_sql}' ORDER BY p.pns_name, k.kvns_name, v.var_key;";
  local results=$(__db_query "${sql}" "-csv");

  if __is_empty "${results}"; then
    log "No keys found matching pattern: '${key_pattern}'.";
    return 1;
  else
    info "Found matching keys in the following contexts:";
    echo "${results}" | while IFS=, read -r pns kvns key; do
      info "  @%s.VAR.%s -> %s" "${pns}" "${kvns}" "${key}";
    done
    return 0;
  fi
}


################################################################################
#
#  do_select_base (New High-Ordinal)
#
################################################################################
# Description: Updates the base_cursor file to change the persistent active base.
do_select_base(){
    local base_name="$1";
    if __is_empty "${base_name}"; then error "Usage: bookdb select <base_name>"; return 1; fi
    __validate_name "${base_name}" "Base Name" || return 1;
    
    # User-level guard: check if base exists
    if ! _list_bases | grep -q "^${base_name}$"; then
        error "Base '${base_name}' not found.";
        return 1;
    fi

    printf "%s" "${base_name}" > "${BOOK_BASE_CURSOR}" || fatal "Failed to write base cursor file: ${BOOK_BASE_CURSOR}";
    okay "Active base changed to '${base_name}'.";
    return 0;
}

################################################################################
#
#  do_current_base (New High-Ordinal)
#
################################################################################
# Description: Prints the active base name.
do_current_base(){
    # THE FIX: Print the raw base name directly to stdout.
    # This aligns with commands like `getv` and is easily capturable.
    # We will add the "Active Base: " decoration in the test script itself if needed.
    printf "%s\n" "${THIS_BASE_NAME}";
    return 0;
}

################################################################################
#
#  do_rebase (New High-Ordinal)
#
################################################################################
# Description: Deletes and recreates a base in a pristine state.
do_rebase(){
  local base_name="$1";
  if __is_empty "${base_name}"; then error "Usage: bookdb rebase <base_name>"; return 1; fi
  __validate_name "${base_name}" "Base Name" || return 1;

  if __confirm_action "Rebase will delete and recreate base '${base_name}'. All data will be lost. Continue?"; then
      _remove_base "${base_name}" || return 1;
      _create_base "${base_name}" || return 1;
      okay "Base '${base_name}' rebased.";
      return 0;
  fi
  log "Rebase cancelled.";
  return 1;
}


################################################################################
#
#  do_unbase (New High-Ordinal)
#
################################################################################
# Description: Deletes the specified .sqlite file.
do_unbase(){
    local base_name="$1";
    if __is_empty "${base_name}"; then error "Usage: bookdb unbase <base_name>"; return 1; fi;
    __validate_name "${base_name}" "Base Name" || return 1;

    # THE FIX: Instead of a simple string check for "main", we can use our new
    # invincible defaults principle. While this function doesn't directly
    # call __require_invincible_defaults, the logic here enforces the same rule.
    if [[ "${base_name}" == "main" ]]; then
        error "Cannot delete the default 'main' base. Use 'rebase main' to reset it.";
        return 1;
    fi;

    # User-level guard: prevent deleting the currently active base
    if [[ "${base_name}" == "${THIS_BASE_NAME}" ]]; then
        error "Cannot delete the currently active base. Use 'select' to switch to another base first.";
        return 1;
    fi;

    if __confirm_action "Delete base '${base_name}' and ALL its contents? This is irreversible."; then
        _remove_base "${base_name}" || return 1;
        return 0;
    fi;
    log "Unbase cancelled.";
    return 1;
}

################################################################################
#
#  ___new_project (Internal Helper)
#
################################################################################
# Description: Internal helper to create a project and its default MAIN keystore.
___new_project(){
  local pns_name="$1";
  if __is_empty "${pns_name}"; then return 1; fi
  local name_sql="${pns_name//\'/\'\'}";
  __db_query "INSERT OR IGNORE INTO project_ns (pns_name) VALUES ('${name_sql}');";
  if [[ $? -eq 0 ]]; then
    okay "Project '${pns_name}' created or already exists.";
    local new_pns_id=$(__db_query "SELECT pns_id FROM project_ns WHERE pns_name = '${name_sql}';" );
    if __is_empty "${new_pns_id}"; then error "Failed to retrieve ID for new project '${pns_name}'."; return 1; fi
    __db_query "INSERT OR IGNORE INTO keyval_ns (kvns_name, pns_id_fk) VALUES ('MAIN', ${new_pns_id});";
    trace "Default key-value store 'MAIN' created/verified for project '${pns_name}'.";
    return 0;
  fi
  error "Failed to create project '${pns_name}'.";
  return 1;
}

################################################################################
#
#  do_new
#
################################################################################
# Description: High-order dispatcher for creating new entities (base, project, keyval).
# Arguments:
#   1: what (string) - "base", "project", or "keyval".
#   2...: name (string, optional) - The name of the entity to create.
# Returns: Exit status of the called helper function.
do_new(){
    local what="$1";
    # Prefer positional name, but fallback to --ns flag for script compatibility
    local name="${2:-${opt_ns}}"; 

    if __is_empty "${what}" || __is_empty "${name}"; then
        error "Usage: bookdb new <base|project|keyval> <name> OR --ns <name>";
        return 1;
    fi

    case "$what" in
        (base) _do_new_base "${name}"; ;;
        (project) _do_new_project "${name}"; ;;
        (keyval) _do_new_keyval "${name}"; ;;
        (*) error "Invalid argument for 'new'. Use 'base', 'project', or 'keyval'."; return 1; ;;
    esac
    return $?;
}

# Mid-Ordinal helpers for `do_new`
_do_new_base(){
    local base_name="$1";
    __validate_name "${base_name}" "Base Name" || return 1;
    # User-level guard: check if base already exists before calling low-level create
    if _list_bases | grep -q "^${base_name}$"; then
      error "Base '${base_name}' already exists.";
      return 1;
    fi
    __backup_db || return 1;
    _create_base "${base_name}";
    return $?;
}

_do_new_project(){
    local pns_name="$1";
    __validate_name "${pns_name}" "Project Name" || return 1;
    __backup_db || return 1;
    ___new_project "${pns_name}";
    return $?;
}

_do_new_keyval(){
    local kvns_name="$1";
    __validate_name "${kvns_name}" "Keystore Name" || return 1;
    # Re-resolve context if a chain was passed on the command line for this specific action.
    if [[ -n "${opt_context_chain}" ]]; then
        __resolve_context || return 1;
    fi
    __backup_db || return 1;
    local name_sql="${kvns_name//\'/\'\'}";
    __db_query "INSERT OR IGNORE INTO keyval_ns (kvns_name, pns_id_fk) VALUES ('${name_sql}', ${BOOK_PNS_ID});";
    if [[ $? -eq 0 ]]; then
        okay "Keystore '${kvns_name}' created in project '${BOOK_PNS_NAME}'.";
        return 0;
    fi
    error "Failed to create keystore '${kvns_name}'. It may already exist.";
    return 1;
}

################################################################################
#
#  do_del
#
################################################################################
# Description: Deletes a project or key-value namespace after confirmation.
do_del(){
  local what="$1"; local ns_name="$2";
  if __is_empty "${what}" || __is_empty "${ns_name}"; then error "Usage: bookdb del <project|keyval> <name>"; return 1; fi
  __validate_name "${ns_name}" "Namespace" || return 1;

  __backup_db || return 1;

  local name_sql="${ns_name//\'/\'\'}";
  case "${what}" in
    (project)
      if [[ "${ns_name}" == "GLOBAL" ]]; then
          error "Cannot delete the indestructible 'GLOBAL' project.";
          return 1;
      fi
      if __confirm_action "Delete project '${ns_name}' and ALL its contents? This is irreversible."; then
        __db_query "DELETE FROM project_ns WHERE pns_name = '${name_sql}';";
        okay "Project '${ns_name}' deleted.";
        return 0;
      fi ;;
    (keyval)
      if is_super_context "${BOOK_PNS_NAME}" "${ns_name}"; then
          error "Cannot delete the indestructible 'MAIN' keystore from the 'GLOBAL' project.";
          return 1;
      fi
      if __confirm_action "Delete key-value store '${ns_name}' in project '${BOOK_PNS_NAME}' and ALL its variables?"; then
        __db_query "DELETE FROM keyval_ns WHERE kvns_name = '${name_sql}' AND pns_id_fk = ${BOOK_PNS_ID};";
        okay "Key-value store '${ns_name}' deleted.";
        return 0;
      fi ;;
    (*) error "Invalid argument for 'del'. Use 'project' or 'keyval'."; return 1; ;;
  esac
  trace "Deletion cancelled or failed.";
  return 1;
}

################################################################################
#
#  do_backup
#
################################################################################
# Description: Creates a full, manual backup of the bookdb installation structure.
do_backup(){
  local backup_path="${HOME}/bookdb_backup_$(date +%Y%m%d_%H%M%S).tar.gz";
  identify;
  info "Creating manual backup at: ${backup_path}";
  
  if [[ -n "${opt_all}" ]]; then
    trace "Backing up all bases and configurations...";
    # Backs up the entire data, etc, and state directories for a full snapshot
    tar -czf "${backup_path}" -C "${_XDG_HOME}" "data/${_XDG_PREF}" "etc/${_XDG_PREF}" "state/${_XDG_PREF}" || { error "Failed to create full backup."; return 1; };
  else
    trace "Backing up current base only ('${THIS_BASE_NAME}')...";
    tar -czf "${backup_path}" -C "$(dirname "${THIS_DB}")" "$(basename "${THIS_DB}")" || { error "Failed to create current base backup."; return 1; };
  fi

  okay "Backup successful.";
  return 0;
}

################################################################################
#
#  do_cursor
#
################################################################################
# Description: Prints the current active cursor chain to stderr.
do_cursor(){ 
  #info "Active Cursor: ${THIS_BASE_NAME}@${BOOK_PNS_NAME}.VAR.${BOOK_KVNS_NAME}";
  printf "%s\n" "${THIS_BASE_NAME}@${BOOK_PNS_NAME}.VAR.${BOOK_KVNS_NAME}";
  return 0; 
}

################################################################################
#
#  do_status
#
################################################################################
# Description: Displays a dashboard with core file paths and system state.
do_status(){
  info "### BookDB (Multi-Base) Status ###";
  info "  Active Database: ${THIS_BASE_NAME} ${THIS_DB}";
  info "  Context Cursor:  ${BOOK_PNS_NAME}.VAR.${BOOK_KVNS_NAME}";
  info "  Projects in Active Base:";
  
  local projects=$(__db_query "SELECT pns_name FROM project_ns ORDER BY pns_name;");
  if [[ -n "${projects}" ]]; then
    echo "${projects}" | while IFS= read -r line; do info "    - %s" "${line}"; done
  else
    info "    (No projects found)";
  fi
  return 0;
}

################################################################################
#
#  __pub_parse_source
#
################################################################################
# Description: Helper to parse the source argument for pub/unpub commands.
__pub_parse_source(){
  local source_arg="$1";
  _PUB_KEY=; _PUB_VALUE=;

  if is_chain "${source_arg}"; then
    _PUB_KEY="${source_arg##*.}";
    __validate_name "${_PUB_KEY}" "Key" || return 1;
    local context_only="${source_arg%.*}";
    local old_opt_chain="${opt_context_chain}";
    opt_context_chain="${context_only}";
    __resolve_context || { opt_context_chain="${old_opt_chain}"; return 1; };
    opt_context_chain="${old_opt_chain}";
    _PUB_VALUE=$(do_getv "${_PUB_KEY}");
    if [[ $? -ne 0 || -z "${_PUB_VALUE}" ]]; then
      error "Key '${_PUB_KEY}' not found or value is empty in context '${context_only}'.";
      return 1;
    fi
  else
    _PUB_KEY="${source_arg%%=*}";
    _PUB_VALUE="${source_arg#*=}";
    if __is_empty "${_PUB_KEY}" || { [[ "${source_arg}" == "${_PUB_KEY}" ]] && [[ "${FUNCNAME[1]}" == "do_pub" ]]; }; then
      error "Invalid key or KEY=VALUE format specified for publish/unpublish.";
      return 1;
    fi
  fi
  return 0;
}

################################################################################
#
#  ___pub_unlink_key
#
################################################################################
# Description: Helper to remove a key-value pair line from a file using sed.
___pub_unlink_key(){
  local key="$1"; local dest="$2";
  if ! is_file "${dest}"; then return 0; fi
  local sentinel_comment="# published by bookdb";
  local sed_script="/^${key}=.*${sentinel_comment}/d";
  __sed_in_place "${sed_script}" "${dest}";
  return $?;
}

################################################################################
#
#  do_pub
#
################################################################################
# Description: Publishes a single key-value pair to an external file.
do_pub(){
  local source_arg="$1"; local dest="$2";

  if __is_empty "${source_arg}" || __is_empty "${dest}"; then
    error "Usage: bookdb pub <@chain.KEY|KEY=VALUE> <destination_file>";
    return 1;
  fi

  if ! is_rw_filepath "${dest}"; then
    error "Destination is not writable or its directory does not exist: ${dest}";
    return 1;
  fi

  __pub_parse_source "${source_arg}" || return 1;

  if __is_empty "${_PUB_VALUE}"; then # If value couldn't be resolved (e.g., key not found)
      error "Could not resolve a value to publish for '${_PUB_KEY}'.";
      return 1;
  fi

  ___pub_unlink_key "${_PUB_KEY}" "${dest}";
  log "Publishing '${_PUB_KEY}' to '${dest}'...";
  local date_str=$(date);
  local output_line="${_PUB_KEY}=\"${_PUB_VALUE}\" # published by bookdb on ${date_str}";
  
  printf "%s\n" "${output_line}" >> "${dest}";
  if [[ $? -eq 0 ]]; then okay "Published key '${_PUB_KEY}' to '${dest}'."; return 0; fi
  error "Failed to write to file: ${dest}";
  return 1;
}

################################################################################
#
#  do_unpub
#
################################################################################
# Description: Removes a published key-value pair from an external file.
do_unpub(){
  local source_arg="$1"; local dest="$2";
  
  if __is_empty "${source_arg}" || __is_empty "${dest}"; then
    error "Usage: bookdb unpub <@chain.KEY|KEY> <destination_file>";
    return 1;
  fi
  

  if ! is_file "${dest}"; then log "File not found: ${dest}. Nothing to unpublish."; return 0; fi

  __pub_parse_source "${source_arg}";
  if __is_empty "${_PUB_KEY}"; then error "Could not determine a key to unpublish."; return 1; fi

  ___pub_unlink_key "${_PUB_KEY}" "${dest}";
  okay "Unpublished '${_PUB_KEY}' from '${dest}' (if it existed).";
  return 0;
}

################################################################################
#
#  do_incv
#
################################################################################
# Description: Increments a numerical variable in the active context.
do_incv(){
  local key="$1"; local amount="${2:-1}";
  if __is_empty "${key}"; then error "Usage: bookdb incv <KEY> [amount]"; return 1; fi
  __validate_name "${key}" "Key" || return 1;
  if ! is_integer "${amount}"; then error "Increment amount must be an integer: '${amount}'."; return 1; fi

  local current_val=$(do_getv "${key}");
  if __is_empty "${current_val}"; then
    current_val=0;
  elif ! is_integer "${current_val}"; then
    error "Cannot increment: Key '${key}' does not have an integer value ('${current_val}').";
    return 1;
  fi
  local new_val=$((current_val + amount));
  log "Incrementing '${key}' to ${new_val}...";
  do_setv "${key}=${new_val}";
  return $?;
}

################################################################################
#
#  do_decv
#
################################################################################
# Description: Decrements a numerical variable in the active context.
do_decv(){
  local key="$1"; local amount="${2:-1}";
  if __is_empty "${key}"; then error "Usage: bookdb decv <KEY> [amount]"; return 1; fi
  __validate_name "${key}" "Key" || return 1;
  if ! is_integer "${amount}"; then error "Decrement amount must be an integer: '${amount}'."; return 1; fi
  
  local current_val=$(do_getv "${key}");
  if __is_empty "${current_val}"; then
    current_val=0;
  elif ! is_integer "${current_val}"; then
    error "Cannot decrement: Key '${key}' does not have an integer value ('${current_val}').";
    return 1;
  fi
  local new_val=$((current_val - amount));
  log "Decrementing '${key}' to ${new_val}...";
  do_setv "${key}=${new_val}";
  return $?;
}

################################################################################
#
#  do_reset
#
################################################################################
# Description: Permanently deletes all bookdb data and artifacts.
do_reset(){
  local msg;
  identify;