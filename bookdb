#!/usr/bin/env bash
#
# bookdb - Final MVP (Phase 5) with Full CRUD Functionality
# A shell-based, context-aware key-value store built on sqlite3.
#

  # @ top
  SELF="APP_BOOKDB";

  readonly BOOK_PREF='bookdb';
  readonly BOOK_NAME="$SELF";
  readonly BOOK_ARGS=("${@}");
  readonly BOOK_PPID="$$";
  readonly BOOK_PATH="$0";
  
  readonly APP_BOOKDB="${BASH_SOURCE[0]}";

#-------------------------------------------------------------------------------
#  Bootstrap
#-------------------------------------------------------------------------------


# Define some colors for clear output headers
  readonly  red2=$'\x1B[38;5;197m';
  readonly  red=$'\x1B[31m';
  readonly  orange=$'\x1B[38;5;214m';
  readonly  yellow=$'\x1B[33m';  

  readonly  green=$'\x1B[32m';
  readonly  blue=$'\x1B[36m';
  readonly  blue2=$'\x1B[38;5;39m';
  readonly  cyan=$'\x1B[38;5;14m';
  readonly  magenta=$'\x1B[35m';  

  readonly  purple=$'\x1B[38;5;213m';
  readonly  purple2=$'\x1B[38;5;141m';
  readonly  white=$'\x1B[38;5;248m';
  readonly  white2=$'\x1B[38;5;15m';
  readonly  grey=$'\x1B[38;5;244m';
  readonly  grey2=$'\x1B[38;5;240m';
  readonly  xx=$'\x1B[0m'; 

  readonly LINE="$(printf '%.0s-' {1..54})";

  stderr(){ [ -z "$QUIET_MODE" ] || [ -n  $2 ] && printf "%b" "${1}$(color xx)\n" 1>&2; }
  fatal(){ stderr "force" "$red$1";  exit 1; }
  error(){ stderr "force" "$red$1"; }
  warn(){  stderr "$orange$1"; }
  okay(){  stderr "$green$1"; }
  info(){  stderr "$blue$1"; }
  magic(){ stderr "$purple$1"; }   
  trace(){ stderr "$grey$1"; } 
  log(){ stderr "$grey$1"; } 
  line(){ stderr "$LINE";  }


#-------------------------------------------------------------------------------
#  Bootstrap
#-------------------------------------------------------------------------------

# --- Developer & Safety Toggles ---
# Set DEV_MODE to true to bypass all [y/N] confirmation prompts.
DEV_MODE=${DEV_MODE:-false};

# Set SAFE_MODE to true to automatically back up the DB before destructive actions.
SAFE_MODE=${SAFE_MODE:-false}

# Add this near the other global toggles (this is auto do not edit)
SAFE_BACKUP_PERFORMED=false;

# XDG+ Paths (as per BASHFX architecture)

# ref: CHANGE TO BASHFX XDG
_XDG_HOME="${HOME}/.local/";
_XDG_PREF="fx/${BOOK_PREF}";

readonly BOOK_LIB="${_XDG_HOME}/lib/fx/app"; #special namespace for external apps

readonly BOOK_BIN="${_XDG_HOME}/bin/${_XDG_PREF}";
readonly BOOK_ETC="${_XDG_HOME}/etc/${_XDG_PREF}";
readonly BOOK_DATA="${_XDG_HOME}/data/${_XDG_PREF}"; 

readonly BOOK_STATE="${_XDG_HOME}/state/${_XDG_PREF}";
readonly BOOK_CACHE="${$HOME}/.cache/${_XDG_PREF}";

readonly BOOK_RC="${BOOK_ETC}/bookrc";
readonly BOOK_DB="${BOOK_DATA}/bookdb.sqlite"; 

readonly BOOK_CURSOR="${BOOK_STATE}/cursor";


#-------------------------------------------------------------------------------
#  Bootstrap
#-------------------------------------------------------------------------------

# Global array to hold arguments after options are parsed.
ARGS=();
# Global context state variables
BOOK_PNS_ID=;
BOOK_PNS_NAME=;
BOOK_KVNS_ID=;
BOOK_KVNS_NAME=;



#-------------------------------------------------------------------------------
#  STDFX
#-------------------------------------------------------------------------------


  _is_empty(){
    [[ -z "${1//[[:space:]]/}" ]];
  }

  is_empty(){
    local var_name;
    for var_name in "$@"; do
      if _is_empty "${!var_name}" ; then
        return 0; # Found an empty one, success (is_empty is true)
      fi
    done;
    return 1; # None were empty
  }




  is_defined(){
    [[ -n "${1//[[:space:]]/}" ]];
  }


  is_file() {
    [ -n "$1" ] && test -f "$1";
  }

# Checks if a given string starts with a context chain prefix (@ or %).
# Returns 0 (true) if it is a chain, 1 (false) otherwise.
  is_chain(){
    [[ "$1" == \@* || "$1" == \%* ]];
    return $?;
  }

# Checks if a path is writable. This means the parent directory is writable,
# and if the file itself exists, it must also be writable.
# Returns 0 (true) if the path is writable, 1 (false) otherwise.
  is_rw_filepath(){
    local path="$1";
    local dir;
    dir=$(dirname "${path}");
    if [[ ! -w "${dir}" ]]; then return 1; fi
    if [[ -e "${path}" && ! -w "${path}" ]]; then return 1; fi
    return 0;
  }

  is_rw_file() {
    [ -n "$1" ] && test -f "$1" -a -r "$1" -a -w "$1";
  }




# Checks if ALL of the given variable NAMES have a non-empty value.
# Usage: is_name "VAR_A" "VAR_B"
# Returns 0 (true) if all have values, 1 (false) if any are empty.
is_name(){
  local var_name;
  for var_name in "$@"; do
    if [[ -z "${!var_name}" ]]; then
      return 1; # Found an empty one, failure
    fi
  done;
  return 0; # All had values
}

# Checks if a given string is a valid integer (positive or negative).
# Returns 0 (true) if it is an integer, 1 (false) otherwise.
is_integer(){
  local val="$1";
  # The regex checks for an optional leading hyphen, followed by one or more digits,
  # and nothing else from start (^) to end ($).
  [[ "${val}" =~ ^-?[0-9]+$ ]];
  return $?;
}

#

#-------------------------------------------------------------------------------
#  Helpers
#-------------------------------------------------------------------------------

__sed_in_place(){
  local sed_script="$1"
  local target_file="$2"

  # Fail early if the target file doesn't exist or isn't writable
  if [[ ! -f "${target_file}" || ! -w "${target_file}" ]]; then
      error "File not found or not writable: ${target_file}"
      return 1
  fi

  # Create a temporary file to hold the modified contents
  local tmp_file
  tmp_file=$(mktemp) || { error "Failed to create temp file for in-place edit."; return 1; }

  # Apply the sed script, redirecting output to the temp file
  if ! sed "${sed_script}" "${target_file}" > "${tmp_file}"; then
      error "sed command failed while processing ${target_file}"
      rm -f "${tmp_file}" # Clean up the temp file on failure
      return 1
  fi

  # Atomically replace the original file with the new one
  if ! mv "${tmp_file}" "${target_file}"; then
      error "Failed to move temp file to overwrite ${target_file}"
      return 1
  fi

  return 0
}

__validate_name(){
  local name_to_check="$1";
  local name_type="$2"; # e.g., "Key", "Project Name"
  # This regex allows alphanumeric characters, underscores, and hyphens.
  # It explicitly forbids characters that could interfere with SQL syntax.
  if ! [[ "${name_to_check}" =~ ^[a-zA-Z0-9_-]+$ ]]; then
    error "Invalid ${name_type}: '${name_to_check}'. Only alphanumeric characters, underscores (_), and hyphens (-) are allowed.";
    return 1;
  fi
  return 0;
}

__db_query(){
  local ret=1;
  local query="$1";
  shift;
  if ! command -v sqlite3 >/dev/null 2>&1; then
    error "sqlite3 command not found. It is a required dependency.";
    return 1;
  fi
  if [[ ! -f "${BOOK_DB}" ]]; then
    error "Database file does not exist: ${BOOK_DB}";
    return 1;
  fi
  sqlite3 "$@" "${BOOK_DB}" "${query}";
  ret=$?;
  if [[ ${ret} -ne 0 ]]; then
    error "Database query failed for: ${query}";
  fi
  return ${ret};
}

__persist_cursor(){
  local pns_name="$1";
  local kvns_name="$2";
  if [[ -z "$pns_name" || -z "$kvns_name" ]]; then
    error "Cannot persist invalid cursor (PNS: ${pns_name}, KVNS: ${kvns_name})";
    return 1;
  fi
  printf "%s\n%s\n" "${pns_name}" "${kvns_name}" > "${BOOK_CURSOR}.tmp";
  mv "${BOOK_CURSOR}.tmp" "${BOOK_CURSOR}" || fatal "Failed to write cursor file";
  return 0;
}

__backup_db(){
  # Skip if SAFE_MODE is off or if backup was already done in this script run
  if [[ "${SAFE_MODE}" != "true" || "${SAFE_BACKUP_PERFORMED}" == "true" ]]; then
    return 0;
  fi
  if [[ ! -f "${BOOK_DB}" ]]; then return 0; fi

  local today;
  today=$(date +%Y-%m-%d);
  local backup_dir="${BOOK_SHARE}/backups";
  local daily_backup_file="${backup_dir}/bookdb-auto-backup-${today}.tar.gz";

  # First, mark as "handled" for this script run to prevent multiple triggers
  SAFE_BACKUP_PERFORMED=true;

  # Then, check if a backup for today already exists
  if [[ -f "${daily_backup_file}" ]]; then
    log "SAFE_MODE: Daily auto-backup for ${today} already exists.";
    return 0;
  fi
  
  mkdir -p "${backup_dir}" || error "Could not create backup directory.";
  log "SAFE_MODE: Performing daily auto-backup to ${daily_backup_file}";
  # We only back up the database file for the automatic safety backup
  tar -czf "${daily_backup_file}" -C "$(dirname "${BOOK_DB}")" "$(basename "${BOOK_DB}")";
  
  if [[ $? -ne 0 ]]; then
    error "Auto-backup failed!";
    return 1;
  fi
  return 0;
}

__confirm_action(){
  local prompt_msg="$1";
  if [[ "${DEV_MODE}" == "true" ]]; then
    log "DEV_MODE: Auto-confirming action.";
    return 0;
  fi
  if [[ -n "$opt_yes" ]]; then
    return 0;
  fi
  local confirm;
  printf "${yellow}%s${xx} [y/N]: " "${prompt_msg}" >&2;
  read confirm;
  if [[ "${confirm}" == "y" || "${confirm}" == "Y" ]]; then
    return 0;
  else
    return 1;
  fi
}

__resolve_context(){
  local ret=1;
  local T_pns_name=;
  local T_kvns_name=;
  local persist_needed=0;
  if [[ -n "${opt_context_chain}" ]]; then
    persist_needed=1;
    local clean_chain="${opt_context_chain#*@}";
    clean_chain="${clean_chain#*%}";
    T_pns_name=$(echo "${clean_chain}" | cut -d'.' -f1);
    T_kvns_name=$(echo "${clean_chain}" | cut -d'.' -f3);
    local context_type=$(echo "${clean_chain}" | cut -d'.' -f2);
    if [[ "${context_type}" != "VAR" ]]; then
      fatal "Invalid context chain: middle part must be 'VAR' (e.g., @myproj.VAR.config)";
    fi
  fi
  if [[ -n "${opt_projdb}" ]]; then
    persist_needed=1;
    T_pns_name="${opt_projdb}";
  fi
  if [[ -n "${opt_keydb}" ]]; then
    persist_needed=1;
    T_kvns_name="${opt_keydb}";
  fi
  if [[ -z "${T_pns_name}" && -z "${T_kvns_name}" ]]; then
    if [[ -f "${BOOK_CURSOR}" ]]; then
      T_pns_name=$(sed -n '1p' "${BOOK_CURSOR}");
      T_kvns_name=$(sed -n '2p' "${BOOK_CURSOR}");
    else
      T_pns_name="GLOBAL";
      T_kvns_name="MAIN";
    fi
  fi
  if [[ -z "${T_pns_name}" ]]; then
      T_pns_name=$(sed -n '1p' "${BOOK_CURSOR}" 2>/dev/null || echo "GLOBAL");
  fi
  if [[ -z "${T_kvns_name}" ]]; then
      T_kvns_name=$(sed -n '2p' "${BOOK_CURSOR}" 2>/dev/null || echo "MAIN");
  fi
  local pns_name_sql="${T_pns_name//\'/\'\'}";
  local kvns_name_sql="${T_kvns_name//\'/\'\'}";
  local T_pns_id;
  T_pns_id=$(__db_query "SELECT pns_id FROM project_ns WHERE pns_name = '${pns_name_sql}';");
  if [[ -z "${T_pns_id}" ]]; then
    error "Project Namespace not found: '${T_pns_name}'";
    return 1;
  fi
  local T_kvns_id;
  T_kvns_id=$(__db_query "SELECT kvns_id FROM keyval_ns WHERE kvns_name = '${kvns_name_sql}' AND pns_id_fk = ${T_pns_id};");
  if [[ -z "${T_kvns_id}" ]]; then
    error "Key-Value Namespace not found: '${T_kvns_name}' in project '${T_pns_name}'";
    return 1;
  fi
  BOOK_PNS_ID="${T_pns_id}";
  BOOK_PNS_NAME="${T_pns_name}";
  BOOK_KVNS_ID="${T_kvns_id}";
  BOOK_KVNS_NAME="${T_kvns_name}";
  if [[ ${persist_needed} -eq 1 ]]; then
    log "Persisting new context to cursor: ${BOOK_PNS_NAME}.${BOOK_KVNS_NAME}";
    __persist_cursor "${BOOK_PNS_NAME}" "${BOOK_KVNS_NAME}";
  fi
  ret=0;
  return ${ret};
}

# ___write_keystore_to_file(){
#   local pns_name="$1";
#   local kvns_name="$2";
#   local target_file="$3";

#   # Find the ID for the given context to query variables
#   local pns_id;
#   pns_id=$(__db_query "SELECT pns_id FROM project_ns WHERE pns_name = '${pns_name}';");
#   local kvns_id;
#   kvns_id=$(__db_query "SELECT kvns_id FROM keyval_ns WHERE kvns_name = '${kvns_name}' AND pns_id_fk = ${pns_id};");

#   if [[ -z "${kvns_id}" ]]; then
#     error "Internal error: Could not find ID for ${pns_name}/${kvns_name}";
#     return 1;
#   fi

#   # Write magic variables to the file header
#   cat << EOF > "${target_file}";
# # bookdb export for keystore: ${kvns_name} in project: ${pns_name}
# _BOOKDB_CHAIN_=@${pns_name}.VAR.${kvns_name}
# _BOOKDB_WRITEMODE_=overwrite

# EOF

#   # Append the variables from the database
#   local sql="SELECT var_key, var_value FROM vars WHERE kvns_id_fk = ${kvns_id} ORDER BY var_key;";
#   __db_query "${sql}" "-separator" "=" >> "${target_file}";

#   return $?;
# }


___write_keystore_to_file() {
  local pns_name="$1"
  local kvns_name="$2"
  local target_file="$3"

  # Find the ID for the given context to query variables
  local pns_id
  pns_id=$(__db_query "SELECT pns_id FROM project_ns WHERE pns_name = '${pns_name}';")
  local kvns_id
  kvns_id=$(__db_query "SELECT kvns_id FROM keyval_ns WHERE kvns_name = '${kvns_name}' AND pns_id_fk = ${pns_id};")

  if [[ -z "${kvns_id}" ]]; then
    __error "Internal error: Could not find ID for ${pns_name}/${kvns_name}"
    return 1
  fi

  # Build the header content in a variable using printf -v for performance and clarity.
  local header_content
  printf -v header_content "# bookdb export for keystore: %s in project: %s\n_BOOKDB_CHAIN_=@%s.VAR.%s\n_BOOKDB_WRITEMODE_=overwrite\n\n" \
    "${kvns_name}" "${pns_name}" "${pns_name}" "${kvns_name}"

  # Write the header to the file, overwriting any existing content.
  # The quotes around "${header_content}" are essential to preserve newlines.
  echo "${header_content}" > "${target_file}"

  # Append the variables from the database to the same file.
  local sql="SELECT var_key, var_value FROM vars WHERE kvns_id_fk = ${kvns_id} ORDER BY var_key;"
  __db_query "${sql}" "-separator" "=" >> "${target_file}"

  return $?
}


___find_shell_profile(){
  # if [[ -n "$ZSH_VERSION" || -f "$HOME/.zshrc" ]]; then
  #   echo "$HOME/.zshrc";
  if [[ -n "$BASH_VERSION" || -f "$HOME/.bashrc" ]]; then
    echo "$HOME/.bashrc";
  elif [[ -f "$HOME/.profile" ]]; then
    echo "$HOME/.profile";
  else
    return 1;
  fi
  return 0;
}

___link_to_profile(){
  local profile_file="$1";
  local sentinel_comment="# bookdb configuration";
  # The new single-line entry with an inline comment
  local link_line="source '${BOOK_RC}' ${sentinel_comment}";

  # We only need to check for our unique sentinel comment to see if we're installed.
  if grep -qF -- "${sentinel_comment}" "${profile_file}" 2>/dev/null; then
    log "Profile '${profile_file}' is already linked.";
    return 0;
  else
    log "Adding bookdb configuration to '${profile_file}'...";
    # Append the single, self-contained line.
    printf "\n%s\n" "${link_line}" >> "${profile_file}";
    return $?;
  fi
}

___unlink_from_profile(){
  local profile_file="$1";
  local sentinel_comment="# bookdb configuration";

  if [[ ! -f "${profile_file}" ]]; then return 0; fi # Nothing to do

  # If our unique comment exists, remove the line using our new helper.
  if grep -qF -- "${sentinel_comment}" "${profile_file}" 2>/dev/null; then
      log "Removing bookdb configuration from '${profile_file}'...";
      local sed_script="/${sentinel_comment}/d";
      __sed_in_place "${sed_script}" "${profile_file}";
      return $?;
  fi
  return 0;
}


# --- Command Functions (Business Logic) ---
#


# Queries and prints all key-value pairs for a given keystore.
# Usage: ___print_keystore_contents <project_name> <keystore_name>
___print_keystore_contents(){
  local pns_name="$1";
  local kvns_name="$2";

  # Sanitize names for the SQL query
  local pns_name_sql="${pns_name//\'/\'\'}";
  local kvns_name_sql="${kvns_name//\'/\'\'}";

  # This query joins all three tables to get the variables by name.
  local sql="SELECT v.var_key, v.var_value FROM vars v JOIN keyval_ns k ON v.kvns_id_fk = k.kvns_id JOIN project_ns p ON k.pns_id_fk = p.pns_id WHERE p.pns_name = '${pns_name_sql}' AND k.kvns_name = '${kvns_name_sql}' ORDER BY v.var_key;"
  
  # Use a pipe separator for robust parsing
  local results;
  results=$(__db_query "${sql}" "-separator" "|");

  if [[ -z "${results}" ]]; then
      printf "      (empty)\n" >&2
  else
      # Use 'while read' to safely handle values that might contain spaces
      echo "${results}" | while IFS="|" read -r key value; do
          printf "    - %s = %s\n" "${key}" "${value}" >&2;
      done
  fi
  return 0;
}


do_ls_all(){
    local projects;
    projects=$(__db_query "SELECT pns_name FROM project_ns ORDER BY pns_name;");
    
    if [[ -z "${projects}" ]]; then
        log "No projects found.";
        return 0;
    fi

    echo "${projects}" | while read -r project; do
        printf "\n${blue}[+] Project: %s${xx}\n" "${project}";
        
        local pns_id;
        pns_id=$(__db_query "SELECT pns_id FROM project_ns WHERE pns_name = '${project}';");
        
        local keystores;
        keystores=$(__db_query "SELECT kvns_name FROM keyval_ns WHERE pns_id_fk = ${pns_id} ORDER BY kvns_name;");

        if [[ -z "${keystores}" ]]; then
            printf "  (No keystores found)\n";
        else
            echo "${keystores}" | while read -r keystore; do
                printf "  - ${yellow}Keystore: %s${xx}\n" "${keystore}";
                ___print_keystore_contents "${project}" "${keystore}";
            done
        fi
    done

    return 0
}


do_getv(){
  local ret=1;
  local key="$1";
  if [[ -z "${key}" ]]; then error "Usage: bookdb getv <KEY>"; return 1; fi
  __validate_name "${key}" "Key" || return 1;
  local key_sql="${key//\'/\'\'}";
  local sql="SELECT var_value FROM vars WHERE var_key = '${key_sql}' AND kvns_id_fk = ${BOOK_KVNS_ID};";
  __db_query "${sql}";
  ret=$?;
  return ${ret};

}

do_setv(){
  local ret=1;
  local arg="$1";
  local key="${arg%%=*}";
  local val="${arg#*=}";
  if [[ -z "$key" || "$arg" == "$key" ]]; then
    error "Usage: bookdb setv <KEY=VALUE>";
    return 1;
  fi
  __validate_name "${key}" "Key" || return 1;
  local key_sql="${key//\'/\'\'}";
  local val_sql="${val//\'/\'\'}";
  local ts;
  ts=$(date +%s);
  local var_id;
  var_id=$(__db_query "SELECT var_id FROM vars WHERE var_key = '${key_sql}' AND kvns_id_fk = ${BOOK_KVNS_ID};");
  
  if [[ -z "${var_id}" ]]; then
    log "Creating new variable: '${key}'";
    local sql_insert="INSERT INTO vars (var_key, var_value, var_updated, kvns_id_fk) VALUES ('${key_sql}', '${val_sql}', ${ts}, ${BOOK_KVNS_ID});";
    __db_query "${sql_insert}";
    ret=$?;
  else
    log "Updating existing variable: '${key}'";
    local sql_update="UPDATE vars SET var_value = '${val_sql}', var_updated = ${ts} WHERE var_id = ${var_id};";
    __db_query "${sql_update}";
    ret=$?;
  fi
  return ${ret};
}

do_delv(){
  local ret=1;
  local key="$1";
  if [[ -z "${key}" ]]; then
    error "Usage: bookdb delv <KEY>";
    return 1;
  fi
  __validate_name "${key}" "Key" || return 1;
  if __confirm_action "Delete variable '${key}' from context '@${BOOK_PNS_NAME}.VAR.${BOOK_KVNS_NAME}'?"; then
    local key_sql="${key//\'/\'\'}";
    __backup_db;
    __db_query "DELETE FROM vars WHERE var_key = '${key_sql}' AND kvns_id_fk = ${BOOK_KVNS_ID};";
    ret=$?;
    log "Deleted variable: ${key}";
  else
    log "Deletion cancelled.";
    ret=1;
  fi
  return ${ret};
}

do_find(){
  local ret=1;
  local key_pattern="$1";
  if [[ -z "${key_pattern}" ]]; then
    error "Usage: bookdb find <KEY_PATTERN>";
    return 1;
  fi

  # Allow for wildcard searching by default if user doesn't provide them.
  if [[ "$key_pattern" != *"%"* ]]; then
    key_pattern="%${key_pattern}%";
  fi

  local key_sql="${key_pattern//\'/\'\'}";
  
  # This query joins all three tables to build the full context for each found key.
  local sql="SELECT p.pns_name, k.kvns_name, v.var_key FROM vars v JOIN keyval_ns k ON v.kvns_id_fk = k.kvns_id JOIN project_ns p ON k.pns_id_fk = p.pns_id WHERE v.var_key LIKE '${key_sql}' ORDER BY p.pns_name, k.kvns_name, v.var_key;";

  local results;
  results=$(__db_query "${sql}" "-csv");

  if [[ -z "${results}" ]]; then
    log "No keys found matching pattern: ${key_pattern}";
    return 1;
  else
    printf "Found matching keys in the following contexts:\n" >&2;
    # Using 'while read' is robust for parsing CSV output from sqlite3
    echo "${results}" | while IFS=, read -r pns kvns key; do
      printf "  ${yellow}@%s.VAR.%s${xx} -> %s\n" "${pns}" "${kvns}" "${key}" >&2;
    done
    ret=0;
  fi
  
  return ${ret};
}

do_ls(){
  local ret=1;
  local what="$1";
  case "${what}" in
    (all)
      do_ls_all
      ret=$?
      ;;
    (project)
      __db_query "SELECT pns_name FROM project_ns ORDER BY pns_name;";
      ret=$?;
      ;;
    (vars)
      local sql="SELECT kvns_name FROM keyval_ns WHERE pns_id_fk = ${BOOK_PNS_ID} ORDER BY kvns_name;";
      __db_query "${sql}";
      ret=$?;
      ;;
    (keys)
      # This provides the old default behavior of listing keys in the current context
      log "Listing keys in active cursor: @${BOOK_PNS_NAME}.VAR.${BOOK_KVNS_NAME}"
      local sql="SELECT var_key FROM vars WHERE kvns_id_fk = ${BOOK_KVNS_ID} ORDER BY var_key;"
      __db_query "${sql}"
      ret=$?
      ;;
    (*)
      error "Invalid argument for 'ls'. Use 'project', 'vars', or no argument.";
      return 1;
      ;;
  esac;
  return ${ret};
}

do_new(){
  local ret=1;
  local what="$1";
  local ns_name="${opt_ns}";
  if [[ -z "${what}" || -z "${ns_name}" ]]; then
    error "Usage: bookdb new <project|keyval> --ns <name>";
    return 1;
  fi
  __validate_name "${ns_name}" "Namespace" || return 1;
  local name_sql="${ns_name//\'/\'\'}";
  case "${what}" in
    (project)
      __backup_db;
      __db_query "INSERT INTO project_ns (pns_name) VALUES ('${name_sql}');";
      if [[ $? -eq 0 ]]; then
        log "Project '${ns_name}' created.";
        local new_pns_id;
        new_pns_id=$(__db_query "SELECT pns_id FROM project_ns WHERE pns_name = '${name_sql}';");
        __db_query "INSERT INTO keyval_ns (kvns_name, pns_id_fk) VALUES ('MAIN', ${new_pns_id});";
        log "Default key-value store 'MAIN' created for project '${ns_name}'.";
        ret=0;
      else
        error "Failed to create project '${ns_name}'. It may already exist.";
        ret=1;
      fi
      ;;
    (keyval)
      __backup_db;
      __db_query "INSERT INTO keyval_ns (kvns_name, pns_id_fk) VALUES ('${name_sql}', ${BOOK_PNS_ID});";
      if [[ $? -eq 0 ]]; then
        log "Key-value store '${ns_name}' created in project '${BOOK_PNS_NAME}'.";
        ret=0;
      else
        error "Failed to create key-value store '${ns_name}'. It may already exist in this project.";
        ret=1;
      fi
      ;;
    (*)
      error "Invalid argument for 'new'. Use 'project' or 'keyval'.";
      ret=1;
      ;;
  esac;
  return ${ret};
}

do_del(){
  local ret=1;
  local what="$1";
  local ns_name="${opt_ns}";
  if [[ -z "${what}" || -z "${ns_name}" ]]; then
    error "Usage: bookdb del <project|keyval> --ns <name>";
    return 1;
  fi
  __validate_name "${ns_name}" "Namespace" || return 1;
  local name_sql="${ns_name//\'/\'\'}";
  case "${what}" in
    (project)
      if __confirm_action "Delete project '${ns_name}' and ALL its contents?"; then
        __backup_db;
        __db_query "DELETE FROM project_ns WHERE pns_name = '${name_sql}';";
        ret=$?;
        log "Project '${ns_name}' deleted.";
      else
        log "Deletion cancelled.";
        ret=1;
      fi
      ;;
    (keyval)
      if __confirm_action "Delete key-value store '${ns_name}' in project '${BOOK_PNS_NAME}'?"; then
        __backup_db;
        __db_query "DELETE FROM keyval_ns WHERE kvns_name = '${name_sql}' AND pns_id_fk = ${BOOK_PNS_ID};";
        ret=$?;
        log "Key-value store '${ns_name}' deleted.";
      else
        log "Deletion cancelled.";
        ret=1;
      fi
      ;;
    (*)
      error "Invalid argument for 'del'. Use 'project' or 'keyval'.";
      ret=1;
      ;;
  esac;
  return ${ret};
}

do_backup(){
  local backup_path="${HOME}/bookdb_backup_$$.tar.gz";

  log "Creating manual, full backup at: ${backup_path}";
  # Backup the entire bookdb installation structure from ~/.local
  tar -czf "${backup_path}" -C "${BOOKDB_ROOT_DIR}" "share/bookdb" "etc/bookdb" "state/bookdb";
  
  if [[ $? -eq 0 ]]; then
      log "Backup successful.";
      return 0;
  else
      error "Backup failed.";
      return 1;
  fi
}

do_cursor(){ 
  printf "Active Cursor: @%s.VAR.%s\n" "${BOOK_PNS_NAME}" "${BOOK_KVNS_NAME}" >&2; 
  return 0; 
}

do_status(){
  printf "--- BookDB Status ---\n" >&2;
  printf "  ${blue}Database File:${xx} %s\n" "${BOOK_DB}" >&2;
  printf "  ${blue}Cursor File:${xx}   %s\n" "${BOOK_CURSOR}" >&2;
  printf "  ${blue}Active Cursor:${xx} ${yellow}@%s.VAR.%s${xx}\n" "${BOOK_PNS_NAME}" "${BOOK_KVNS_NAME}" >&2;
  printf "  ${blue}Projects:${xx}\n" >&2;
  local projects; projects=$(do_ls "project");
  if [[ -n "${projects}" ]]; then echo "${projects}" | sed 's/^/    - /' >&2;
  else printf "    (No projects found)\n" >&2; fi
  return 0;
}

___pub_parse_source(){
  # This helper parses the source argument (@chain.KEY or KEY=VALUE)
  # and sets the global variables _PUB_KEY and _PUB_VALUE.
  local source_arg="$1";

  # Reset globals to ensure clean state
  _PUB_KEY=;
  _PUB_VALUE=;

  if [[ "${source_arg}" == \@* || "${source_arg}" == \%* ]]; then
    # CONTEXT MODE
    # _PUB_KEY=$(echo "${source_arg}" | sed 's/.*\.//');
    # #_PUB_KEY="${source_arg##*.}
    # local context_only;
    # context_only=$(echo "${source_arg}" | sed "s/\.${_PUB_KEY}$//");

    # More robustly get the part after the last dot
    _PUB_KEY="${source_arg##*.}";
    __validate_name "${_PUB_KEY}" "Key" || return 1;
    local context_only;
    # More robustly get the part before the last dot
    context_only="${source_arg%.*}";

    # Temporarily set opt_context_chain to use the existing resolver
    local old_opt_chain="${opt_context_chain}";
    opt_context_chain="${context_only}";
    __resolve_context || { opt_context_chain="${old_opt_chain}"; return 1; };
    opt_context_chain="${old_opt_chain}"; # Restore it
    
    _PUB_VALUE=$(do_getv "${_PUB_KEY}");
    if [[ -z "${_PUB_VALUE}" ]]; then
      error "Key '${_PUB_KEY}' not found in context '${context_only}'.";
      return 1;
    fi
  else
    # LITERAL MODE
    _PUB_KEY="${source_arg%%=*}";
    _PUB_VALUE="${source_arg#*=}";
    # For unpub, value might be empty, but for pub, key must be different from arg
    if [[ -z "${_PUB_KEY}" ]]; then
      error "Invalid key specified for publish/unpublish.";
      return 1;
    fi
  fi
  return 0;
}

___pub_unlink_key(){
  # This helper performs the sed operation to remove a key from a file.
  local key="$1";
  local dest="$2";

  if [[ ! -f "${dest}" ]]; then return 0; fi # Nothing to do

  local sentinel_comment="# published by bookdb"
  # The sed script will find the line starting with the key, followed by the sentinel, and delete it.
  local sed_script="/^${key}=.*${sentinel_comment}/d";

  __sed_in_place "${sed_script}" "${dest}";
  return $?;
}


do_pub(){
  local ret=1;
  local source_arg="$1";
  local dest="$2";

  if [[ -z "${source_arg}" || -z "${dest}" ]]; then
    error "Usage: bookdb pub <@chain.KEY|KEY=VALUE> <destination_file>";
    return 1;
  fi

  # REFACTORED: Using the new guard for a much cleaner check.
  if ! is_rw_filepath "${dest}"; then
    error "Destination is not writable: ${dest}";
    return 1;
  fi

  # Use the helper to parse the source and get the key/value
  ___pub_parse_source "${source_arg}" || return 1;
  
  if [[ "${source_arg}" != *"="* && -z "${_PUB_VALUE}" ]]; then
      error "Could not resolve a value to publish for '${_PUB_KEY}'.";
      return 1;
  fi

  ___pub_unlink_key "${_PUB_KEY}" "${dest}";
  log "Publishing '${_PUB_KEY}' to '${dest}'...";
  local date_str;
  date_str=$(date);
  local output_line="${_PUB_KEY}=\"${_PUB_VALUE}\" # published by bookdb on ${date_str}";
  
  printf "%s\n" "${output_line}" >> "${dest}";
  if [[ $? -eq 0 ]]; then
    ret=0;
  else
    error "Failed to write to file: ${dest}";
  fi
  return ${ret};
}

do_unpub(){
  local ret=1;
  local source_arg="$1";
  local dest="$2";

  if [[ -z "${source_arg}" || -z "${dest}" ]]; then
    error "Usage: bookdb unpub <@chain.KEY|KEY> <destination_file>";
    return 1;
  fi
  
  # REFACTORED: Using the new guard simplifies the file check.
  if ! is_file "${dest}"; then
    error "File not found: ${dest}";
    return 1;
  fi

  ___pub_parse_source "${source_arg}";
  if [[ -z "${_PUB_KEY}" ]]; then
    error "Could not determine a key to unpublish.";
    return 1;
  fi

  ___pub_unlink_key "${_PUB_KEY}" "${dest}";
  log "Unpublished '${_PUB_KEY}' from '${dest}' (if it existed).";
  ret=0;
  return ${ret};
}

do_incv(){
  local ret=1;
  local key="$1";
  local amount="${2:-1}"; # Default increment is 1 if not specified

  if [[ -z "${key}" ]]; then
    error "Usage: bookdb incv <KEY> [amount]";
    return 1;
  fi
  __validate_name "${key}" "Key" || return 1;
  local current_val;
  current_val=$(do_getv "${key}");
  
  # REFACTORED: Use the new guard for a much cleaner check.
  if [[ -n "${current_val}" ]] && ! is_integer "${current_val}"; then
    error "Cannot increment: Key '${key}' does not have an integer value ('${current_val}').";
    return 1;
  fi

  # If current_val is empty, the arithmetic operation treats it as 0 automatically.
  local new_val=$((current_val + amount));
  log "Incrementing '${key}' to ${new_val}...";
  do_setv "${key}=${new_val}";
  ret=$?;
  
  return ${ret};
}

do_decv(){
  local ret=1;
  local key="$1";
  local amount="${2:-1}"; # Default decrement is 1 if not specified

  if [[ -z "${key}" ]]; then
    error "Usage: bookdb decv <KEY> [amount]";
    return 1;
  fi
  __validate_name "${key}" "Key" || return 1;
  local current_val;
  current_val=$(do_getv "${key}");

  # REFACTORED: Use the new guard here as well.
  if [[ -n "${current_val}" ]] && ! is_integer "${current_val}"; then
    error "Cannot decrement: Key '${key}' does not have an integer value ('${current_val}').";
    return 1;
  fi

  local new_val=$((current_val - amount));
  log "Decrementing '${key}' to ${new_val}...";
  do_setv "${key}=${new_val}";
  ret=$?;

  return ${ret};
}

do_reset(){
  local profile_file;
  profile_file=$(___find_shell_profile);

  if __confirm_action "This will permanently delete all bookdb data and uninstall the command. Continue?"; then
    __backup_db;
    log "Proceeding with full reset and uninstall...";
    
    # Unlink from shell profile
    if [[ -n "${profile_file}" ]]; then
      ___unlink_from_profile "${profile_file}";
    fi
    
    # Remove installed directories and the binary
    rm -rf "${BOOK_SHARE}" "${BOOK_ETC}" "${BOOKDB_STATE_DIR}";
    rm -f "${BOOK_BIN}/${BOOK_PREF}";

    
    printf "\n[OKAY] Reset and uninstall complete.\n\n" >&2;
    printf "To clear your shell's command cache, run the following command:\n\n" >&2;
    printf "    hash -r\n\n" >&2;
    printf "You may also need to start a new shell session for changes to take full effect.\n" >&2;
    return 0;
  else
    log "Reset cancelled.";
    return 1;
  fi
}

do_migrate(){
  local ret=0;
  local backup_dir="bookdb_fullbak_$$";
  
  log "Starting full migration export to directory: ./${backup_dir}";
  mkdir -p "${backup_dir}" || fatal "Could not create migration directory.";
  
  # Get a list of all project/keystore pairs
  local sql="SELECT p.pns_name, k.kvns_name FROM project_ns p JOIN keyval_ns k ON p.pns_id = k.pns_id_fk;";
  local results;
  results=$(__db_query "${sql}" "-csv");
  
  if [[ -z "${results}" ]]; then
    log "No keystores found to migrate.";
    return 0;
  fi

  echo "${results}" | while IFS=, read -r pns kvns; do
    local filename="${backup_dir}/${pns}_${kvns}.env";
    log "  -> Exporting ${pns}/${kvns} to ${filename}";
    ___write_keystore_to_file "${pns}" "${kvns}" "${filename}";
    if [[ $? -ne 0 ]]; then ret=1; fi
  done

  if [[ ${ret} -eq 0 ]]; then
    log "Migration complete.";
  else
    error "Migration completed with errors.";
  fi
  return ${ret};
}

do_export(){
  local ret=1;
  local what="$1";

  if [[ "${what}" != "keystore" ]]; then
    error "Usage: bookdb export keystore [<context>]";
    return 1;
  fi

  local target_filename="${BOOK_PNS_NAME}_${BOOK_KVNS_NAME}.env";
  log "Exporting context '@${BOOK_PNS_NAME}.VAR.${BOOK_KVNS_NAME}' to ./${target_filename}";
  
  ___write_keystore_to_file "${BOOK_PNS_NAME}" "${BOOK_KVNS_NAME}" "${target_filename}";
  ret=$?;
  
  return ${ret};
}


do_import(){
  local ret=1;
  local file_path="$1";
  if [[ -z "${file_path}" ]]; then error "Usage: bookdb import <file.env>"; return 1; fi
  if [[ ! -r "${file_path}" ]]; then error "File not found or not readable: ${file_path}"; return 1; fi

  log "Parsing file: ${file_path}";
  local keys_to_import=(); local vals_to_import=();
  local T_keystore=; local T_chain=; local T_filter=; local T_writemode="overwrite";

  while IFS= read -r line || [[ -n "$line" ]]; do
    line=$(echo "${line}" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//');
    [[ -z "$line" || "$line" == \#* ]] && continue;
    line="${line#export }"; local key="${line%%=*}"; local val="${line#*=}";
    [[ "$key" == "$line" ]] && continue;
    case "$key" in
      (_BOOKDB_KEYSTORE_) T_keystore="${val}"; continue ;;
      (_BOOKDB_CHAIN_)    T_chain="${val}"; continue ;;
      (_BOOKDB_FILTER_)   T_filter="${val}"; continue ;;
      (_BOOKDB_WRITEMODE_) T_writemode="${val}"; continue ;;
    esac;
    if [[ "$key" =~ ^[A-Z0-9_]+$ ]]; then
      keys_to_import+=("$key"); vals_to_import+=("$val");
    fi
  done < "${file_path}";
  
  # (Filtering logic remains the same)
  local f_scope="public"; local f_prefix=; local f_suffix=; local f_contain=;
  if [[ -n "${T_filter}" ]]; then
      local IFS_bak=$IFS; IFS=',';
      for part in ${T_filter}; do
          case "$part" in (scope=*) f_scope="${part#*=}" ;; (prefix=*) f_prefix="${part#*=}" ;; (suffix=*) f_suffix="${part#*=}" ;; (contain=*) f_contain="${part#*=}" ;; esac;
      done
      IFS=$IFS_bak;
  fi
  local filtered_keys=(); local filtered_vals=(); local i;
  for i in "${!keys_to_import[@]}"; do
    local key="${keys_to_import[$i]}"; local is_private=false;
    [[ "$key" == _* ]] && is_private=true;
    case "${f_scope}" in (public) if [[ "${is_private}" == true ]]; then continue; fi ;; (private) if [[ "${is_private}" == false ]]; then continue; fi ;; esac;
    if [[ -n "$f_prefix" && "$key" != "$f_prefix"* ]]; then continue; fi
    if [[ -n "$f_suffix" && "$key" != *"$f_suffix" ]]; then continue; fi
    if [[ -n "$f_contain" && "$key" != *"$f_contain"* ]]; then continue; fi
    filtered_keys+=("$key"); filtered_vals+=("${vals_to_import[$i]}");
  done

  if [[ ${#filtered_keys[@]} -eq 0 ]]; then error "No keys to import after filtering."; return 1; fi

  # Infer context from filename if no other context is specified
  if [[ -z "${T_chain}" && -z "${T_keystore}" ]]; then
    local basename="${file_path##*/}";
    local pns_kvns="${basename%.env}";
    if [[ "${pns_kvns}" == *"_"* && "${basename}" != "${pns_kvns}" ]]; then
      # Robustly split on the LAST underscore.
      # This handles names like 'my_project_name' and 'secrets'.
      local pns="${pns_kvns%_*}";
      local kvns="${pns_kvns##*_}";
      T_chain="@${pns}.VAR.${kvns}";
      log "Inferred context from filename: ${T_chain}";
    fi
  fi

  # Resolve target context
  if [[ -n "${T_chain}" ]]; then opt_context_chain="${T_chain}"; __resolve_context || return 1;
  elif [[ -n "${T_keystore}" ]]; then opt_keydb="${T_keystore}"; __resolve_context || return 1;
  fi

  # (Confirmation and import logic remains the same)
  printf "The following ${#filtered_keys[@]} keys will be imported into context:\n" >&2;
  printf "${yellow}@%s.VAR.%s${xx} with write mode: %s${xx}\n" "${BOOK_PNS_NAME}" "${BOOK_KVNS_NAME}" "${T_writemode}" >&2;
  printf -- "$LINE\n" >&2;
  for key in "${filtered_keys[@]}"; do printf "  - %s\n" "$key" >&2; done
  printf -- "$LINE\n" >&2;
  if __confirm_action "Proceed with import?"; then
    log "Importing keys...";
    for i in "${!filtered_keys[@]}"; do
      local key_to_import="${filtered_keys[$i]}";
      if [[ "${T_writemode}" == "addonly" ]]; then
        local existing_val; existing_val=$(do_getv "${key_to_import}");
        if [[ -n "${existing_val}" ]]; then log "Skipping existing key (addonly): ${key_to_import}"; continue; fi
      fi
      do_setv "${key_to_import}=${filtered_vals[$i]}";
    done
    log "Import complete."; ret=0;
  else
    log "Import cancelled by user."; ret=1;
  fi
  return ${ret};
}

__setup_sql(){

  log "Creating/verifying database schema...";

  # Create the database schema
  touch "${BOOK_DB}" || fatal "Failed to create database file";

  local sql_create_pns="CREATE TABLE IF NOT EXISTS project_ns (pns_id INTEGER PRIMARY KEY, pns_name TEXT UNIQUE NOT NULL);";
  local sql_create_kvns="CREATE TABLE IF NOT EXISTS keyval_ns (kvns_id INTEGER PRIMARY KEY, kvns_name TEXT NOT NULL, pns_id_fk INTEGER, FOREIGN KEY(pns_id_fk) REFERENCES project_ns(pns_id) ON DELETE CASCADE, UNIQUE(kvns_name, pns_id_fk));";
  local sql_create_vars="CREATE TABLE IF NOT EXISTS vars (var_id INTEGER PRIMARY KEY, var_key TEXT NOT NULL, var_value TEXT, var_updated INTEGER, kvns_id_fk INTEGER, FOREIGN KEY(kvns_id_fk) REFERENCES keyval_ns(kvns_id) ON DELETE CASCADE);";

  __db_query "${sql_create_pns}"  || fatal "Failed table: project_ns";
  __db_query "${sql_create_kvns}" || fatal "Failed table: keyval_ns";
  __db_query "${sql_create_vars}" || fatal "Failed table: vars";
  __db_query "INSERT OR IGNORE INTO project_ns (pns_name) VALUES ('GLOBAL');";

  local global_pns_id=$(__db_query "SELECT pns_id FROM project_ns WHERE pns_name = 'GLOBAL';");
  # Corrected from IGNORE to IGNORE
  __db_query "INSERT OR IGNORE INTO keyval_ns (kvns_name, pns_id_fk) VALUES ('MAIN', ${global_pns_id});";

}


__setup_dirs(){
  # Create all directories, including the new bin dir
  log "Creating XDG+ directories...";
  mkdir -p "${BOOK_SHARE}" "${BOOK_ETC}" "${BOOKDB_STATE_DIR}" "${BOOK_BIN}" || fatal "Failed to create directories";
}

__setup_confirm(){

  if [[ -z "${1}" ]]; then
    error "Could not find a suitable shell profile (~/.bashrc, ~/.zshrc, ~/.profile).";
    error "Please create one and run install again.";
    return 1;
  fi
  
  info "The installer will perform the following actions:\n";

  printf "  1. Create directories in: %s\n" "${BOOKDB_ROOT_DIR}" >&2;
  printf "  2. Copy itself to:        %s/%s\n" "${BOOK_BIN}" "${BOOK_PREF}" >&2;
  printf "  3. Modify your shell profile: %s\n" "${profile_file}" >&2;

  if ! __confirm_action "Proceed with full installation?"; then
    log "Installation cancelled.";
    return 1;
  fi

}




do_install(){

  local ret=1 profile_file script_path;

  profile_file=$(___find_shell_profile);


  __setup_confirm "$profile_file" || return 1;
  __setup_dirs;

  # Copy and permission the script
  info "Installing script to ${BOOK_BIN}/${BOOK_PREF}...";



  script_path=$(cd "$(dirname "${BOOK_PATH}")" &> /dev/null && pwd)/$(basename "${BOOK_PATH}");

  _cp_path="${BOOK_BIN}/${BOOK_PREF}";

  echo "Path is $_cp_path | $script_path";

  cp "${script_path}" "${BOOK_BIN}/";
  if [[ $? -ne 0 ]]; then fatal "Failed to copy script to bin directory."; fi

  chmod +x "${BOOK_BIN}/${BOOK_PREF}";



  __setup_sql;

  # Generate the NEW rc file with PATH logic
  log "Generating RC file with PATH configuration...";
  cat << EOF > "${BOOK_RC}";
# bookdb runtime configuration
export BOOKDB_HOME="${BOOK_SHARE}";
export BOOKDB_INSTALLED="true";

# Add bookdb bin to PATH if it's not already there.
if [[ -d "${BOOK_BIN}" ]]; then
  case ":\$PATH:" in
    *:"${BOOK_BIN}":*) ;;
    *) export PATH="${BOOK_BIN}:\$PATH" ;;
  esac
fi
EOF

  # Link the RC file to the user's main shell profile
  ___link_to_profile "${profile_file}" "source '${BOOK_RC}'";

  printf "\n[OKAY] Installation complete!\n\n" >&2;
  printf "Please restart your shell or run 'source %s' to begin using the 'bookdb' command.\n" "${profile_file}" >&2;
  ret=0;
  return ${ret};
}


do_tables(){ printf "Tables in %s:\n" "${BOOK_DB}" >&2; __db_query ".tables" >&2; return $?; };

do_tdump(){
  local table_name="$1";
  if [[ -z "${table_name}" ]]; then error "Usage: bookdb tdump <TABLE_NAME>"; return 1; fi
  if ! [[ "${table_name}" =~ ^[a-zA-Z0-9_]+$ ]]; then error "Invalid table name specified."; return 1; fi
  printf "Dumping table: %s\n" "${table_name}" >&2;
  __db_query "SELECT * FROM ${table_name};" "-header" "-column" >&2;
  return $?;
}

do_dev_setup(){
  log "Starting developer test setup...";
  do_reset;
  if [[ $? -ne 0 ]]; then fatal "Reset cancelled during dev-setup."; fi
  do_install;
  if [[ $? -ne 0 ]]; then fatal "Installation failed during dev-setup."; fi
  log "Inserting test data via direct queries...";
  __db_query "INSERT OR IGNORE INTO project_ns (pns_name) VALUES ('myapp');";
  local myapp_id;
  myapp_id=$(__db_query "SELECT pns_id FROM project_ns WHERE pns_name = 'myapp';");
  local global_id;
  global_id=$(__db_query "SELECT pns_id FROM project_ns WHERE pns_name = 'GLOBAL';");
  __db_query "INSERT OR IGNORE INTO keyval_ns (kvns_name, pns_id_fk) VALUES ('secrets', ${global_id});";
  __db_query "INSERT OR IGNORE INTO keyval_ns (kvns_name, pns_id_fk) VALUES ('apis', ${myapp_id});";
  local secrets_id;
  secrets_id=$(__db_query "SELECT kvns_id from keyval_ns WHERE kvns_name = 'secrets' AND pns_id_fk = ${global_id};");
  __db_query "INSERT OR IGNORE INTO vars (var_key, var_value, kvns_id_fk) VALUES ('DB_PASS', 'supersecret', ${secrets_id});";
  local apis_id;
  apis_id=$(__db_query "SELECT kvns_id from keyval_ns WHERE kvns_name = 'apis' AND pns_id_fk = ${myapp_id};");
  __db_query "INSERT OR IGNORE INTO vars (var_key, var_value, kvns_id_fk) VALUES ('GOOGLE_API_KEY', 'key-for-google', ${apis_id});";
  log "Developer setup complete.";

# import test block
  log "Creating example .env files for import tests...";
  
  # Test file for the default (public scope)
  cat << EOF > "${HOME}/bookdb_test_public.env";
# By default, only public keys should be imported.
_BOOKDB_CHAIN_=@myapp.VAR.apis

# Public keys
export SERVICE_A_URL=https://service-a.com/api
SERVICE_B_URL=https://service-b.com/api

# Ignored private key
_PRIVATE_KEY=should_be_ignored
EOF

  # Test file for importing ONLY private keys
  cat << EOF > "${HOME}/bookdb_test_private.env";
_BOOKDB_CHAIN_=@myapp.VAR.apis
_BOOKDB_FILTER_=scope=private

# Public keys (should be ignored)
PUBLIC_KEY=should_be_ignored

# Private keys (should be imported)
_SECRET_TOKEN=token-12345
_API_USER=private_user
EOF

  # Test file for importing ALL keys
  cat << EOF > "${HOME}/bookdb_test_all.env";
_BOOKDB_CHAIN_=@myapp.VAR.apis
_BOOKDB_FILTER_=scope=all

# Public keys
PUBLIC_KEY_1=public1
PUBLIC_KEY_2=public2

# Private keys
_PRIVATE_KEY_1=private1
_PRIVATE_KEY_2=private2
EOF

  # Test file for the 'addonly' write mode
  cat << EOF > "${HOME}/bookdb_test_addonly.env";
# This file tests the addonly write mode.
_BOOKDB_CHAIN_=@myapp.VAR.apis
_BOOKDB_WRITEMODE_=addonly

# This key already exists, so it should be SKIPPED.
GOOGLE_API_KEY=this_value_should_be_ignored

# This is a new key, so it should be ADDED.
NEW_SERVICE_KEY=this_value_should_be_added
EOF

  return 0;
}


#
# --- Core Application Logic ---
#

usage(){
  cat << EOF >&2
Usage: bookdb <command> [args...] [flags...] [<context-chain>]

A shell-based key-value store.

Core Commands:${xx}
  status                   - Display a dashboard of the system's state.
  cursor                   - Print the current active cursor chain.
  ls [project|vars|keys]   - List all data, projects, keystores, or keys in context.
  find <PATTERN>           - Find a key across all projects/keystores.
  getv <KEY>               - Get the value of a variable.
  setv <KEY=VALUE>         - Create or update a variable.
  delv <KEY>               - Delete a variable.
  pub <@chain.key> <file>  - Publish a single key-value pair to a file.
  unpub <@chain.key> <file> - Remove a published key-value pair from a file.
  incv <KEY> [amount]      - Increment a numerical value (default: 1).
  decv <KEY> [amount]      - Decrement a numerical value (default: 1).
  new <project|keyval> --ns <name>
                           - Create a new project or key-value namespace.
  del <project|keyval> --ns <name>
                           - Delete a project or key-value namespace.

Admin & I/O Commands:${xx}
  install                  - Create or verify a bookdb installation.
  reset                    - DELETE ALL DATA and artifacts.
  backup                   - Create a full, versioned backup in \$HOME.
  dev_setup                - Create a standard set of test data.
  export keystore          - Export a keystore to a PNS_KVNS.env file.
  import <file.env>        - Import keys from a .env file into a context.
  migrate                  - Export all keystores to a backup directory.
  tables                   - List all tables in the database.
  tdump <NAME>             - Dump the contents of a specific table.

Flags:${xx}
  -y, --yes                - Auto-confirm 'yes' to all prompts.
  -p, --projdb <name>      - Set project namespace for this command.
  -k, --keydb <name>       - Set key-value namespace for this command.

Context Prefixes:${xx}
  @...                     - Use context and persist it to the cursor.
  %...                     - Use context for one command only (read-only).

Scripting & Automation Examples:${xx}
  # Mass import/restore all .env files from a migration directory:
  for file in bookdb_fullbak_*/; do ./bookdb import "\$file" -y; done

  # Export all keystores from the 'GLOBAL' project only:
  for ks in \$(./bookdb ls vars @GLOBAL.VAR.MAIN); do
    ./bookdb export keystore @GLOBAL.VAR.\$ks
  done

EOF
  exit 1;
}


options(){
  local local_args=();
  opt_quiet=; opt_projdb=; opt_keydb=; opt_context_chain=; opt_ns=; opt_yes=;
  while [ $# -gt 0 ]; do
    case "$1" in
      (-q|--quiet) opt_quiet=1; shift; ;;
      (-y|--yes) opt_yes=1; shift; ;;
      (-p|--projdb) opt_projdb="$2"; shift 2; ;;
      (-k|--keydb) opt_keydb="$2"; shift 2; ;;
      (--ns) opt_ns="$2"; shift 2; ;;
      (--) shift; local_args+=("$@"); break; ;;
      (-*) error "Unknown option: $1"; usage; ;;
      (*) local_args+=("$1"); shift; ;;
    esac;
  done;
  local last_arg_idx=$((${#local_args[@]} - 1));
  if [[ ${last_arg_idx} -ge 0 ]]; then
    local last_arg="${local_args[${last_arg_idx}]}";
    # REFACTORED: Using the new guard for clarity.
    if is_chain "${last_arg}"; then
      opt_context_chain="${last_arg}";
      unset 'local_args[${last_arg_idx}]';
    fi
  fi
  ARGS=("${local_args[@]}");
  return 0;
}

# @todo : dispatch
dispatch(){
  local ret=1;
  local cmd="${ARGS[0]}";
  if [[ -z "$cmd" ]]; then usage; fi
  case "$cmd" in
    (st|status) do_status; ret=$?; ;;
    (c|cursor) do_cursor; ret=$?; ;;
    (export) do_export "${ARGS[1]}"; ret=$?; ;;
    (import) do_import "${ARGS[1]}"; ret=$?; ;;
    (migrate) do_migrate; ret=$?; ;;
    (getv) do_getv "${ARGS[1]}"; ret=$?; ;;
    (setv) do_setv "${ARGS[1]}"; ret=$?; ;;
    (delv) do_delv "${ARGS[1]}"; ret=$?; ;;
    (incv) do_incv "${ARGS[1]}" "${ARGS[2]}"; ret=$?; ;;
    (decv) do_decv "${ARGS[1]}" "${ARGS[2]}"; ret=$?; ;;
    (ls) do_ls "${ARGS[1]}"; ret=$?; ;;
    (find) do_find "${ARGS[1]}"; ret=$?; ;;
    (new) do_new; ret=$?; ;;
    (del) do_del; ret=$?; ;;
    (pub) do_pub "${ARGS[1]}" "${ARGS[2]}"; ret=$?; ;;
    (unpub)   do_unpub "${ARGS[1]}" "${ARGS[2]}"; ret=$?; ;;
    (tables) do_tables; ret=$?; ;;
    (tdump) do_tdump "${ARGS[1]}"; ret=$?; ;;
    (reset) do_reset; ret=$?; ;;
    (install) do_install; ret=$?; ;;
    (dev_setup) do_dev_setup; ret=$?; ;;
    (backup) do_backup; ret=$?; ;;
    (*) error "Unknown command: ${cmd}"; usage; ;;
  esac;
  return ${ret};
}

main(){
  # Handle simple, self-contained commands that must run regardless of installation state.
  # They are called directly and exit immediately, bypassing the main options parser.
  case "$1" in
    (help)_ usage; exit 1; ;;
    (reset)
      # Manually parse -y for this specific case before calling the function.
      if [[ "$2" == "-y" || "$2" == "--yes" ]]; then opt_yes=1; fi
      do_reset; exit $?;
      ;;
    (install)
      do_install; exit $?;
      ;;
    (backup)
      do_backup; exit $?;
      ;;
    (import)
      do_import; exit $?;
      ;;
    (export)
      do_export; exit $?;
      ;;
    (dev_setup)
      if [[ "$2" == "-y" || "$2" == "--yes" ]]; then opt_yes=1; fi
      do_dev_setup; exit $?;
      ;;
  esac;

  # If we are here, the command was not one of the simple ones above.
  # Now, proceed with the normal installation check and full options parsing.

  # If not installed, check for DEV_MODE or prompt the user.
  if [[ ! -f "${BOOK_DB}" ]]; then
    if [[ "${DEV_MODE}" == "true" ]]; then
      log "DEV_MODE: Auto-installing on first run.";
      do_install;
    else
      local confirm_install;
      printf "BookDB appears to be uninstalled.\n" >&2;
      printf "Would you like to run the installer now? [y/N]: " >&2;
      read confirm_install;
      if [[ "${confirm_install}" == "y" || "${confirm_install}" == "Y" ]]; then
        do_install; exit $?;
      else
        log "Installation cancelled by user. Exiting."; exit 1;
      fi
    fi
  fi

  # Regular execution flow
  options "$@";
  if [[ -n "$opt_quiet" ]]; then QUIET_MODE=true; fi

  # Handle commands that need DB but not context
  case "${ARGS[0]}" in
      (tables|tdump) dispatch; exit $?; ;;
  esac;

  # Handle all other commands that require context
  __resolve_context || exit 1;
  dispatch;
  local ret=$?;
  return ${ret};
}

#
# --- Execution Entry Point ---
#
main "$@";
